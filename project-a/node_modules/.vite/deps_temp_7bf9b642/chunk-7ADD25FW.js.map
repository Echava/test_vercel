{
  "version": 3,
  "sources": ["../../svelte/src/internal/client/dom/blocks/snippet.js", "../../svelte/src/internal/client/dev/elements.js", "../../svelte/src/internal/client/dev/legacy.js", "../../svelte/src/internal/client/dom/blocks/each.js", "../../svelte/src/internal/client/dom/blocks/slot.js", "../../svelte/src/internal/client/dom/blocks/svelte-element.js", "../../svelte/src/internal/client/dom/elements/misc.js", "../../svelte/src/internal/client/dom/elements/attributes.js", "../../svelte/src/internal/client/dom/elements/bindings/size.js", "../../svelte/src/internal/client/dom/legacy/lifecycle.js", "../../svelte/src/internal/client/reactivity/props.js", "../../svelte/src/internal/client/dom/elements/custom-element.js"],
  "sourcesContent": ["/** @import { Snippet } from 'svelte' */\r\n/** @import { Effect, TemplateNode } from '#client' */\r\n/** @import { Getters } from '#shared' */\r\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\r\nimport { branch, block, destroy_effect, teardown } from '../../reactivity/effects.js';\r\nimport {\r\n\tdev_current_component_function,\r\n\tset_dev_current_component_function\r\n} from '../../runtime.js';\r\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\r\nimport { create_fragment_from_html } from '../reconciler.js';\r\nimport { assign_nodes } from '../template.js';\r\nimport * as w from '../../warnings.js';\r\nimport * as e from '../../errors.js';\r\nimport { DEV } from 'esm-env';\r\nimport { get_first_child, get_next_sibling } from '../operations.js';\r\nimport { noop } from '../../../shared/utils.js';\r\n\r\n/**\r\n * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn\r\n * @param {TemplateNode} node\r\n * @param {() => SnippetFn | null | undefined} get_snippet\r\n * @param {(() => any)[]} args\r\n * @returns {void}\r\n */\r\nexport function snippet(node, get_snippet, ...args) {\r\n\tvar anchor = node;\r\n\r\n\t/** @type {SnippetFn | null | undefined} */\r\n\t// @ts-ignore\r\n\tvar snippet = noop;\r\n\r\n\t/** @type {Effect | null} */\r\n\tvar snippet_effect;\r\n\r\n\tblock(() => {\r\n\t\tif (snippet === (snippet = get_snippet())) return;\r\n\r\n\t\tif (snippet_effect) {\r\n\t\t\tdestroy_effect(snippet_effect);\r\n\t\t\tsnippet_effect = null;\r\n\t\t}\r\n\r\n\t\tif (DEV && snippet == null) {\r\n\t\t\te.invalid_snippet();\r\n\t\t}\r\n\r\n\t\tsnippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));\r\n\t}, EFFECT_TRANSPARENT);\r\n\r\n\tif (hydrating) {\r\n\t\tanchor = hydrate_node;\r\n\t}\r\n}\r\n\r\n/**\r\n * In development, wrap the snippet function so that it passes validation, and so that the\r\n * correct component context is set for ownership checks\r\n * @param {any} component\r\n * @param {(node: TemplateNode, ...args: any[]) => void} fn\r\n */\r\nexport function wrap_snippet(component, fn) {\r\n\treturn (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => {\r\n\t\tvar previous_component_function = dev_current_component_function;\r\n\t\tset_dev_current_component_function(component);\r\n\r\n\t\ttry {\r\n\t\t\treturn fn(node, ...args);\r\n\t\t} finally {\r\n\t\t\tset_dev_current_component_function(previous_component_function);\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * Create a snippet programmatically\r\n * @template {unknown[]} Params\r\n * @param {(...params: Getters<Params>) => {\r\n *   render: () => string\r\n *   setup?: (element: Element) => void | (() => void)\r\n * }} fn\r\n * @returns {Snippet<Params>}\r\n */\r\nexport function createRawSnippet(fn) {\r\n\t// @ts-expect-error the types are a lie\r\n\treturn (/** @type {TemplateNode} */ anchor, /** @type {Getters<Params>} */ ...params) => {\r\n\t\tvar snippet = fn(...params);\r\n\r\n\t\t/** @type {Element} */\r\n\t\tvar element;\r\n\r\n\t\tif (hydrating) {\r\n\t\t\telement = /** @type {Element} */ (hydrate_node);\r\n\t\t\thydrate_next();\r\n\t\t} else {\r\n\t\t\tvar html = snippet.render().trim();\r\n\t\t\tvar fragment = create_fragment_from_html(html);\r\n\t\t\telement = /** @type {Element} */ (get_first_child(fragment));\r\n\r\n\t\t\tif (DEV && (get_next_sibling(element) !== null || element.nodeType !== 1)) {\r\n\t\t\t\tw.invalid_raw_snippet_render();\r\n\t\t\t}\r\n\r\n\t\t\tanchor.before(element);\r\n\t\t}\r\n\r\n\t\tconst result = snippet.setup?.(element);\r\n\t\tassign_nodes(element, element);\r\n\r\n\t\tif (typeof result === 'function') {\r\n\t\t\tteardown(result);\r\n\t\t}\r\n\t};\r\n}\r\n", "/** @import { SourceLocation } from '#shared' */\r\nimport { HYDRATION_END, HYDRATION_START, HYDRATION_START_ELSE } from '../../../constants.js';\r\nimport { hydrating } from '../dom/hydration.js';\r\n\r\n/**\r\n * @param {any} fn\r\n * @param {string} filename\r\n * @param {SourceLocation[]} locations\r\n * @returns {any}\r\n */\r\nexport function add_locations(fn, filename, locations) {\r\n\treturn (/** @type {any[]} */ ...args) => {\r\n\t\tconst dom = fn(...args);\r\n\r\n\t\tvar node = hydrating ? dom : dom.nodeType === 11 ? dom.firstChild : dom;\r\n\t\tassign_locations(node, filename, locations);\r\n\r\n\t\treturn dom;\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {Element} element\r\n * @param {string} filename\r\n * @param {SourceLocation} location\r\n */\r\nfunction assign_location(element, filename, location) {\r\n\t// @ts-expect-error\r\n\telement.__svelte_meta = {\r\n\t\tloc: { file: filename, line: location[0], column: location[1] }\r\n\t};\r\n\r\n\tif (location[2]) {\r\n\t\tassign_locations(element.firstChild, filename, location[2]);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Node | null} node\r\n * @param {string} filename\r\n * @param {SourceLocation[]} locations\r\n */\r\nfunction assign_locations(node, filename, locations) {\r\n\tvar i = 0;\r\n\tvar depth = 0;\r\n\r\n\twhile (node && i < locations.length) {\r\n\t\tif (hydrating && node.nodeType === 8) {\r\n\t\t\tvar comment = /** @type {Comment} */ (node);\r\n\t\t\tif (comment.data === HYDRATION_START || comment.data === HYDRATION_START_ELSE) depth += 1;\r\n\t\t\telse if (comment.data[0] === HYDRATION_END) depth -= 1;\r\n\t\t}\r\n\r\n\t\tif (depth === 0 && node.nodeType === 1) {\r\n\t\t\tassign_location(/** @type {Element} */ (node), filename, locations[i++]);\r\n\t\t}\r\n\r\n\t\tnode = node.nextSibling;\r\n\t}\r\n}\r\n", "import * as e from '../errors.js';\r\nimport { component_context } from '../runtime.js';\r\nimport { FILENAME } from '../../../constants.js';\r\nimport { get_component } from './ownership.js';\r\n\r\n/** @param {Function & { [FILENAME]: string }} target */\r\nexport function check_target(target) {\r\n\tif (target) {\r\n\t\te.component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);\r\n\t}\r\n}\r\n\r\nexport function legacy_api() {\r\n\tconst component = component_context?.function;\r\n\r\n\t/** @param {string} method */\r\n\tfunction error(method) {\r\n\t\t// @ts-expect-error\r\n\t\tconst parent = get_component()?.[FILENAME] ?? 'Something';\r\n\t\te.component_api_changed(parent, method, component[FILENAME]);\r\n\t}\r\n\r\n\treturn {\r\n\t\t$destroy: () => error('$destroy()'),\r\n\t\t$on: () => error('$on(...)'),\r\n\t\t$set: () => error('$set(...)')\r\n\t};\r\n}\r\n", "/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\r\nimport {\r\n\tEACH_INDEX_REACTIVE,\r\n\tEACH_IS_ANIMATED,\r\n\tEACH_IS_CONTROLLED,\r\n\tEACH_ITEM_IMMUTABLE,\r\n\tEACH_ITEM_REACTIVE,\r\n\tHYDRATION_END,\r\n\tHYDRATION_START_ELSE\r\n} from '../../../../constants.js';\r\nimport {\r\n\thydrate_next,\r\n\thydrate_node,\r\n\thydrating,\r\n\tremove_nodes,\r\n\tset_hydrate_node,\r\n\tset_hydrating\r\n} from '../hydration.js';\r\nimport {\r\n\tclear_text_content,\r\n\tcreate_text,\r\n\tget_first_child,\r\n\tget_next_sibling\r\n} from '../operations.js';\r\nimport {\r\n\tblock,\r\n\tbranch,\r\n\tdestroy_effect,\r\n\trun_out_transitions,\r\n\tpause_children,\r\n\tpause_effect,\r\n\tresume_effect\r\n} from '../../reactivity/effects.js';\r\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\r\nimport { array_from, is_array } from '../../../shared/utils.js';\r\nimport { INERT } from '../../constants.js';\r\nimport { queue_micro_task } from '../task.js';\r\nimport { active_effect } from '../../runtime.js';\r\n\r\n/**\r\n * The row of a keyed each block that is currently updating. We track this\r\n * so that `animate:` directives have something to attach themselves to\r\n * @type {EachItem | null}\r\n */\r\nexport let current_each_item = null;\r\n\r\n/** @param {EachItem | null} item */\r\nexport function set_current_each_item(item) {\r\n\tcurrent_each_item = item;\r\n}\r\n\r\n/**\r\n * @param {any} _\r\n * @param {number} i\r\n */\r\nexport function index(_, i) {\r\n\treturn i;\r\n}\r\n\r\n/**\r\n * Pause multiple effects simultaneously, and coordinate their\r\n * subsequent destruction. Used in each blocks\r\n * @param {EachState} state\r\n * @param {EachItem[]} items\r\n * @param {null | Node} controlled_anchor\r\n * @param {Map<any, EachItem>} items_map\r\n */\r\nfunction pause_effects(state, items, controlled_anchor, items_map) {\r\n\t/** @type {TransitionManager[]} */\r\n\tvar transitions = [];\r\n\tvar length = items.length;\r\n\r\n\tfor (var i = 0; i < length; i++) {\r\n\t\tpause_children(items[i].e, transitions, true);\r\n\t}\r\n\r\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\r\n\t// If we have a controlled anchor, it means that the each block is inside a single\r\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\r\n\tif (is_controlled) {\r\n\t\tvar parent_node = /** @type {Element} */ (\r\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\r\n\t\t);\r\n\t\tclear_text_content(parent_node);\r\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\r\n\t\titems_map.clear();\r\n\t\tlink(state, items[0].prev, items[length - 1].next);\r\n\t}\r\n\r\n\trun_out_transitions(transitions, () => {\r\n\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\tvar item = items[i];\r\n\t\t\tif (!is_controlled) {\r\n\t\t\t\titems_map.delete(item.k);\r\n\t\t\t\tlink(state, item.prev, item.next);\r\n\t\t\t}\r\n\t\t\tdestroy_effect(item.e, !is_controlled);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * @template V\r\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\r\n * @param {number} flags\r\n * @param {() => V[]} get_collection\r\n * @param {(value: V, index: number) => any} get_key\r\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\r\n * @param {null | ((anchor: Node) => void)} fallback_fn\r\n * @returns {void}\r\n */\r\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\r\n\tvar anchor = node;\r\n\r\n\t/** @type {EachState} */\r\n\tvar state = { flags, items: new Map(), first: null };\r\n\r\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\r\n\r\n\tif (is_controlled) {\r\n\t\tvar parent_node = /** @type {Element} */ (node);\r\n\r\n\t\tanchor = hydrating\r\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\r\n\t\t\t: parent_node.appendChild(create_text());\r\n\t}\r\n\r\n\tif (hydrating) {\r\n\t\thydrate_next();\r\n\t}\r\n\r\n\t/** @type {Effect | null} */\r\n\tvar fallback = null;\r\n\r\n\tvar was_empty = false;\r\n\r\n\tblock(() => {\r\n\t\tvar collection = get_collection();\r\n\r\n\t\tvar array = is_array(collection)\r\n\t\t\t? collection\r\n\t\t\t: collection == null\r\n\t\t\t\t? []\r\n\t\t\t\t: array_from(collection);\r\n\r\n\t\tvar length = array.length;\r\n\r\n\t\tif (was_empty && length === 0) {\r\n\t\t\t// ignore updates if the array is empty,\r\n\t\t\t// and it already was empty on previous run\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twas_empty = length === 0;\r\n\r\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\r\n\t\tlet mismatch = false;\r\n\r\n\t\tif (hydrating) {\r\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\r\n\r\n\t\t\tif (is_else !== (length === 0)) {\r\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\r\n\t\t\t\tanchor = remove_nodes();\r\n\r\n\t\t\t\tset_hydrate_node(anchor);\r\n\t\t\t\tset_hydrating(false);\r\n\t\t\t\tmismatch = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// this is separate to the previous block because `hydrating` might change\r\n\t\tif (hydrating) {\r\n\t\t\t/** @type {EachItem | null} */\r\n\t\t\tvar prev = null;\r\n\r\n\t\t\t/** @type {EachItem} */\r\n\t\t\tvar item;\r\n\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tif (\r\n\t\t\t\t\thydrate_node.nodeType === 8 &&\r\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\r\n\t\t\t\t) {\r\n\t\t\t\t\t// The server rendered fewer items than expected,\r\n\t\t\t\t\t// so break out and continue appending non-hydrated items\r\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\r\n\t\t\t\t\tmismatch = true;\r\n\t\t\t\t\tset_hydrating(false);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar value = array[i];\r\n\t\t\t\tvar key = get_key(value, i);\r\n\t\t\t\titem = create_item(hydrate_node, state, prev, null, value, key, i, render_fn, flags);\r\n\t\t\t\tstate.items.set(key, item);\r\n\r\n\t\t\t\tprev = item;\r\n\t\t\t}\r\n\r\n\t\t\t// remove excess nodes\r\n\t\t\tif (length > 0) {\r\n\t\t\t\tset_hydrate_node(remove_nodes());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!hydrating) {\r\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key);\r\n\t\t}\r\n\r\n\t\tif (fallback_fn !== null) {\r\n\t\t\tif (length === 0) {\r\n\t\t\t\tif (fallback) {\r\n\t\t\t\t\tresume_effect(fallback);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\r\n\t\t\t\t}\r\n\t\t\t} else if (fallback !== null) {\r\n\t\t\t\tpause_effect(fallback, () => {\r\n\t\t\t\t\tfallback = null;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (mismatch) {\r\n\t\t\t// continue in hydration mode\r\n\t\t\tset_hydrating(true);\r\n\t\t}\r\n\r\n\t\t// When we mount the each block for the first time, the collection won't be\r\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\r\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\r\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\r\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\r\n\t\t// will now be `CLEAN`.\r\n\t\tget_collection();\r\n\t});\r\n\r\n\tif (hydrating) {\r\n\t\tanchor = hydrate_node;\r\n\t}\r\n}\r\n\r\n/**\r\n * Add, remove, or reorder items output by an each block as its input changes\r\n * @template V\r\n * @param {Array<V>} array\r\n * @param {EachState} state\r\n * @param {Element | Comment | Text} anchor\r\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>) => void} render_fn\r\n * @param {number} flags\r\n * @param {(value: V, index: number) => any} get_key\r\n * @returns {void}\r\n */\r\nfunction reconcile(array, state, anchor, render_fn, flags, get_key) {\r\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\r\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\r\n\r\n\tvar length = array.length;\r\n\tvar items = state.items;\r\n\tvar first = state.first;\r\n\tvar current = first;\r\n\r\n\t/** @type {undefined | Set<EachItem>} */\r\n\tvar seen;\r\n\r\n\t/** @type {EachItem | null} */\r\n\tvar prev = null;\r\n\r\n\t/** @type {undefined | Set<EachItem>} */\r\n\tvar to_animate;\r\n\r\n\t/** @type {EachItem[]} */\r\n\tvar matched = [];\r\n\r\n\t/** @type {EachItem[]} */\r\n\tvar stashed = [];\r\n\r\n\t/** @type {V} */\r\n\tvar value;\r\n\r\n\t/** @type {any} */\r\n\tvar key;\r\n\r\n\t/** @type {EachItem | undefined} */\r\n\tvar item;\r\n\r\n\t/** @type {number} */\r\n\tvar i;\r\n\r\n\tif (is_animated) {\r\n\t\tfor (i = 0; i < length; i += 1) {\r\n\t\t\tvalue = array[i];\r\n\t\t\tkey = get_key(value, i);\r\n\t\t\titem = items.get(key);\r\n\r\n\t\t\tif (item !== undefined) {\r\n\t\t\t\titem.a?.measure();\r\n\t\t\t\t(to_animate ??= new Set()).add(item);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (i = 0; i < length; i += 1) {\r\n\t\tvalue = array[i];\r\n\t\tkey = get_key(value, i);\r\n\t\titem = items.get(key);\r\n\r\n\t\tif (item === undefined) {\r\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\r\n\r\n\t\t\tprev = create_item(\r\n\t\t\t\tchild_anchor,\r\n\t\t\t\tstate,\r\n\t\t\t\tprev,\r\n\t\t\t\tprev === null ? state.first : prev.next,\r\n\t\t\t\tvalue,\r\n\t\t\t\tkey,\r\n\t\t\t\ti,\r\n\t\t\t\trender_fn,\r\n\t\t\t\tflags\r\n\t\t\t);\r\n\r\n\t\t\titems.set(key, prev);\r\n\r\n\t\t\tmatched = [];\r\n\t\t\tstashed = [];\r\n\r\n\t\t\tcurrent = prev.next;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (should_update) {\r\n\t\t\tupdate_item(item, value, i, flags);\r\n\t\t}\r\n\r\n\t\tif ((item.e.f & INERT) !== 0) {\r\n\t\t\tresume_effect(item.e);\r\n\t\t\tif (is_animated) {\r\n\t\t\t\titem.a?.unfix();\r\n\t\t\t\t(to_animate ??= new Set()).delete(item);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (item !== current) {\r\n\t\t\tif (seen !== undefined && seen.has(item)) {\r\n\t\t\t\tif (matched.length < stashed.length) {\r\n\t\t\t\t\t// more efficient to move later items to the front\r\n\t\t\t\t\tvar start = stashed[0];\r\n\t\t\t\t\tvar j;\r\n\r\n\t\t\t\t\tprev = start.prev;\r\n\r\n\t\t\t\t\tvar a = matched[0];\r\n\t\t\t\t\tvar b = matched[matched.length - 1];\r\n\r\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\r\n\t\t\t\t\t\tmove(matched[j], start, anchor);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\r\n\t\t\t\t\t\tseen.delete(stashed[j]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlink(state, a.prev, b.next);\r\n\t\t\t\t\tlink(state, prev, a);\r\n\t\t\t\t\tlink(state, b, start);\r\n\r\n\t\t\t\t\tcurrent = start;\r\n\t\t\t\t\tprev = b;\r\n\t\t\t\t\ti -= 1;\r\n\r\n\t\t\t\t\tmatched = [];\r\n\t\t\t\t\tstashed = [];\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// more efficient to move earlier items to the back\r\n\t\t\t\t\tseen.delete(item);\r\n\t\t\t\t\tmove(item, current, anchor);\r\n\r\n\t\t\t\t\tlink(state, item.prev, item.next);\r\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\r\n\t\t\t\t\tlink(state, prev, item);\r\n\r\n\t\t\t\t\tprev = item;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tmatched = [];\r\n\t\t\tstashed = [];\r\n\r\n\t\t\twhile (current !== null && current.k !== key) {\r\n\t\t\t\t// If the item has an effect that is already inert, skip over adding it\r\n\t\t\t\t// to our seen Set as the item is already being handled\r\n\t\t\t\tif ((current.e.f & INERT) === 0) {\r\n\t\t\t\t\t(seen ??= new Set()).add(current);\r\n\t\t\t\t}\r\n\t\t\t\tstashed.push(current);\r\n\t\t\t\tcurrent = current.next;\r\n\t\t\t}\r\n\r\n\t\t\tif (current === null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\titem = current;\r\n\t\t}\r\n\r\n\t\tmatched.push(item);\r\n\t\tprev = item;\r\n\t\tcurrent = item.next;\r\n\t}\r\n\r\n\tif (current !== null || seen !== undefined) {\r\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\r\n\r\n\t\twhile (current !== null) {\r\n\t\t\t// Inert effects are currently outroing and will be removed once the transition is finished\r\n\t\t\tif ((current.e.f & INERT) === 0) {\r\n\t\t\t\tto_destroy.push(current);\r\n\t\t\t}\r\n\t\t\tcurrent = current.next;\r\n\t\t}\r\n\r\n\t\tvar destroy_length = to_destroy.length;\r\n\r\n\t\tif (destroy_length > 0) {\r\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\r\n\r\n\t\t\tif (is_animated) {\r\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\r\n\t\t\t\t\tto_destroy[i].a?.measure();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\r\n\t\t\t\t\tto_destroy[i].a?.fix();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\r\n\t\t}\r\n\t}\r\n\r\n\tif (is_animated) {\r\n\t\tqueue_micro_task(() => {\r\n\t\t\tif (to_animate === undefined) return;\r\n\t\t\tfor (item of to_animate) {\r\n\t\t\t\titem.a?.apply();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\r\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\r\n}\r\n\r\n/**\r\n * @param {EachItem} item\r\n * @param {any} value\r\n * @param {number} index\r\n * @param {number} type\r\n * @returns {void}\r\n */\r\nfunction update_item(item, value, index, type) {\r\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\r\n\t\tinternal_set(item.v, value);\r\n\t}\r\n\r\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\r\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\r\n\t} else {\r\n\t\titem.i = index;\r\n\t}\r\n}\r\n\r\n/**\r\n * @template V\r\n * @param {Node} anchor\r\n * @param {EachState} state\r\n * @param {EachItem | null} prev\r\n * @param {EachItem | null} next\r\n * @param {V} value\r\n * @param {unknown} key\r\n * @param {number} index\r\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>) => void} render_fn\r\n * @param {number} flags\r\n * @returns {EachItem}\r\n */\r\nfunction create_item(anchor, state, prev, next, value, key, index, render_fn, flags) {\r\n\tvar previous_each_item = current_each_item;\r\n\r\n\ttry {\r\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\r\n\t\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\r\n\r\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\r\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\r\n\r\n\t\t/** @type {EachItem} */\r\n\t\tvar item = {\r\n\t\t\ti,\r\n\t\t\tv,\r\n\t\t\tk: key,\r\n\t\t\ta: null,\r\n\t\t\t// @ts-expect-error\r\n\t\t\te: null,\r\n\t\t\tprev,\r\n\t\t\tnext\r\n\t\t};\r\n\r\n\t\tcurrent_each_item = item;\r\n\t\titem.e = branch(() => render_fn(anchor, v, i), hydrating);\r\n\r\n\t\titem.e.prev = prev && prev.e;\r\n\t\titem.e.next = next && next.e;\r\n\r\n\t\tif (prev === null) {\r\n\t\t\tstate.first = item;\r\n\t\t} else {\r\n\t\t\tprev.next = item;\r\n\t\t\tprev.e.next = item.e;\r\n\t\t}\r\n\r\n\t\tif (next !== null) {\r\n\t\t\tnext.prev = item;\r\n\t\t\tnext.e.prev = item.e;\r\n\t\t}\r\n\r\n\t\treturn item;\r\n\t} finally {\r\n\t\tcurrent_each_item = previous_each_item;\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {EachItem} item\r\n * @param {EachItem | null} next\r\n * @param {Text | Element | Comment} anchor\r\n */\r\nfunction move(item, next, anchor) {\r\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\r\n\r\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\r\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\r\n\r\n\twhile (node !== end) {\r\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\r\n\t\tdest.before(node);\r\n\t\tnode = next_node;\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {EachState} state\r\n * @param {EachItem | null} prev\r\n * @param {EachItem | null} next\r\n */\r\nfunction link(state, prev, next) {\r\n\tif (prev === null) {\r\n\t\tstate.first = next;\r\n\t} else {\r\n\t\tprev.next = next;\r\n\t\tprev.e.next = next && next.e;\r\n\t}\r\n\r\n\tif (next !== null) {\r\n\t\tnext.prev = prev;\r\n\t\tnext.e.prev = prev && prev.e;\r\n\t}\r\n}\r\n", "import { hydrate_next, hydrating } from '../hydration.js';\r\n\r\n/**\r\n * @param {Comment} anchor\r\n * @param {Record<string, any>} $$props\r\n * @param {string} name\r\n * @param {Record<string, unknown>} slot_props\r\n * @param {null | ((anchor: Comment) => void)} fallback_fn\r\n */\r\nexport function slot(anchor, $$props, name, slot_props, fallback_fn) {\r\n\tif (hydrating) {\r\n\t\thydrate_next();\r\n\t}\r\n\r\n\tvar slot_fn = $$props.$$slots?.[name];\r\n\t// Interop: Can use snippets to fill slots\r\n\tvar is_interop = false;\r\n\tif (slot_fn === true) {\r\n\t\tslot_fn = $$props[name === 'default' ? 'children' : name];\r\n\t\tis_interop = true;\r\n\t}\r\n\r\n\tif (slot_fn === undefined) {\r\n\t\tif (fallback_fn !== null) {\r\n\t\t\tfallback_fn(anchor);\r\n\t\t}\r\n\t} else {\r\n\t\tslot_fn(anchor, is_interop ? () => slot_props : slot_props);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Record<string, any>} props\r\n * @returns {Record<string, boolean>}\r\n */\r\nexport function sanitize_slots(props) {\r\n\t/** @type {Record<string, boolean>} */\r\n\tconst sanitized = {};\r\n\tif (props.children) sanitized.default = true;\r\n\tfor (const key in props.$$slots) {\r\n\t\tsanitized[key] = true;\r\n\t}\r\n\treturn sanitized;\r\n}\r\n", "/** @import { Effect, TemplateNode } from '#client' */\r\nimport { FILENAME, NAMESPACE_SVG } from '../../../../constants.js';\r\nimport {\r\n\thydrate_next,\r\n\thydrate_node,\r\n\thydrating,\r\n\tset_hydrate_node,\r\n\tset_hydrating\r\n} from '../hydration.js';\r\nimport { create_text, get_first_child } from '../operations.js';\r\nimport {\r\n\tblock,\r\n\tbranch,\r\n\tdestroy_effect,\r\n\tpause_effect,\r\n\tresume_effect\r\n} from '../../reactivity/effects.js';\r\nimport { set_should_intro } from '../../render.js';\r\nimport { current_each_item, set_current_each_item } from './each.js';\r\nimport { component_context, active_effect } from '../../runtime.js';\r\nimport { DEV } from 'esm-env';\r\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\r\nimport { assign_nodes } from '../template.js';\r\n\r\n/**\r\n * @param {Comment | Element} node\r\n * @param {() => string} get_tag\r\n * @param {boolean} is_svg\r\n * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,\r\n * @param {undefined | (() => string)} get_namespace\r\n * @param {undefined | [number, number]} location\r\n * @returns {void}\r\n */\r\nexport function element(node, get_tag, is_svg, render_fn, get_namespace, location) {\r\n\tlet was_hydrating = hydrating;\r\n\r\n\tif (hydrating) {\r\n\t\thydrate_next();\r\n\t}\r\n\r\n\tvar filename = DEV && location && component_context?.function[FILENAME];\r\n\r\n\t/** @type {string | null} */\r\n\tvar tag;\r\n\r\n\t/** @type {string | null} */\r\n\tvar current_tag;\r\n\r\n\t/** @type {null | Element} */\r\n\tvar element = null;\r\n\r\n\tif (hydrating && hydrate_node.nodeType === 1) {\r\n\t\telement = /** @type {Element} */ (hydrate_node);\r\n\t\thydrate_next();\r\n\t}\r\n\r\n\tvar anchor = /** @type {TemplateNode} */ (hydrating ? hydrate_node : node);\r\n\r\n\t/** @type {Effect | null} */\r\n\tvar effect;\r\n\r\n\t/**\r\n\t * The keyed `{#each ...}` item block, if any, that this element is inside.\r\n\t * We track this so we can set it when changing the element, allowing any\r\n\t * `animate:` directive to bind itself to the correct block\r\n\t */\r\n\tvar each_item_block = current_each_item;\r\n\r\n\tblock(() => {\r\n\t\tconst next_tag = get_tag() || null;\r\n\t\tvar ns = get_namespace ? get_namespace() : is_svg || next_tag === 'svg' ? NAMESPACE_SVG : null;\r\n\r\n\t\t// Assumption: Noone changes the namespace but not the tag (what would that even mean?)\r\n\t\tif (next_tag === tag) return;\r\n\r\n\t\t// See explanation of `each_item_block` above\r\n\t\tvar previous_each_item = current_each_item;\r\n\t\tset_current_each_item(each_item_block);\r\n\r\n\t\tif (effect) {\r\n\t\t\tif (next_tag === null) {\r\n\t\t\t\t// start outro\r\n\t\t\t\tpause_effect(effect, () => {\r\n\t\t\t\t\teffect = null;\r\n\t\t\t\t\tcurrent_tag = null;\r\n\t\t\t\t});\r\n\t\t\t} else if (next_tag === current_tag) {\r\n\t\t\t\t// same tag as is currently rendered — abort outro\r\n\t\t\t\tresume_effect(effect);\r\n\t\t\t} else {\r\n\t\t\t\t// tag is changing — destroy immediately, render contents without intro transitions\r\n\t\t\t\tdestroy_effect(effect);\r\n\t\t\t\tset_should_intro(false);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (next_tag && next_tag !== current_tag) {\r\n\t\t\teffect = branch(() => {\r\n\t\t\t\telement = hydrating\r\n\t\t\t\t\t? /** @type {Element} */ (element)\r\n\t\t\t\t\t: ns\r\n\t\t\t\t\t\t? document.createElementNS(ns, next_tag)\r\n\t\t\t\t\t\t: document.createElement(next_tag);\r\n\r\n\t\t\t\tif (DEV && location) {\r\n\t\t\t\t\t// @ts-expect-error\r\n\t\t\t\t\telement.__svelte_meta = {\r\n\t\t\t\t\t\tloc: {\r\n\t\t\t\t\t\t\tfile: filename,\r\n\t\t\t\t\t\t\tline: location[0],\r\n\t\t\t\t\t\t\tcolumn: location[1]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\r\n\t\t\t\tassign_nodes(element, element);\r\n\r\n\t\t\t\tif (render_fn) {\r\n\t\t\t\t\t// If hydrating, use the existing ssr comment as the anchor so that the\r\n\t\t\t\t\t// inner open and close methods can pick up the existing nodes correctly\r\n\t\t\t\t\tvar child_anchor = /** @type {TemplateNode} */ (\r\n\t\t\t\t\t\thydrating ? get_first_child(element) : element.appendChild(create_text())\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif (hydrating) {\r\n\t\t\t\t\t\tif (child_anchor === null) {\r\n\t\t\t\t\t\t\tset_hydrating(false);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tset_hydrate_node(child_anchor);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// `child_anchor` is undefined if this is a void element, but we still\r\n\t\t\t\t\t// need to call `render_fn` in order to run actions etc. If the element\r\n\t\t\t\t\t// contains children, it's a user error (which is warned on elsewhere)\r\n\t\t\t\t\t// and the DOM will be silently discarded\r\n\t\t\t\t\trender_fn(element, child_anchor);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// we do this after calling `render_fn` so that child effects don't override `nodes.end`\r\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = element;\r\n\r\n\t\t\t\tanchor.before(element);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\ttag = next_tag;\r\n\t\tif (tag) current_tag = tag;\r\n\t\tset_should_intro(true);\r\n\r\n\t\tset_current_each_item(previous_each_item);\r\n\t}, EFFECT_TRANSPARENT);\r\n\r\n\tif (was_hydrating) {\r\n\t\tset_hydrating(true);\r\n\t\tset_hydrate_node(anchor);\r\n\t}\r\n}\r\n", "import { hydrating } from '../hydration.js';\r\nimport { clear_text_content, get_first_child } from '../operations.js';\r\nimport { queue_micro_task } from '../task.js';\r\n\r\n/**\r\n * @param {HTMLElement} dom\r\n * @param {boolean} value\r\n * @returns {void}\r\n */\r\nexport function autofocus(dom, value) {\r\n\tif (value) {\r\n\t\tconst body = document.body;\r\n\t\tdom.autofocus = true;\r\n\r\n\t\tqueue_micro_task(() => {\r\n\t\t\tif (document.activeElement === body) {\r\n\t\t\t\tdom.focus();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * The child of a textarea actually corresponds to the defaultValue property, so we need\r\n * to remove it upon hydration to avoid a bug when someone resets the form value.\r\n * @param {HTMLTextAreaElement} dom\r\n * @returns {void}\r\n */\r\nexport function remove_textarea_child(dom) {\r\n\tif (hydrating && get_first_child(dom) !== null) {\r\n\t\tclear_text_content(dom);\r\n\t}\r\n}\r\n\r\nlet listening_to_form_reset = false;\r\n\r\nexport function add_form_reset_listener() {\r\n\tif (!listening_to_form_reset) {\r\n\t\tlistening_to_form_reset = true;\r\n\t\tdocument.addEventListener(\r\n\t\t\t'reset',\r\n\t\t\t(evt) => {\r\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\r\n\t\t\t\t// elements have not updated to their reset values yet\r\n\t\t\t\tPromise.resolve().then(() => {\r\n\t\t\t\t\tif (!evt.defaultPrevented) {\r\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\r\n\t\t\t\t\t\t\t// @ts-expect-error\r\n\t\t\t\t\t\t\te.__on_r?.();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\r\n\t\t\t{ capture: true }\r\n\t\t);\r\n\t}\r\n}\r\n", "import { DEV } from 'esm-env';\r\nimport { hydrating } from '../hydration.js';\r\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\r\nimport { create_event, delegate } from './events.js';\r\nimport { add_form_reset_listener, autofocus } from './misc.js';\r\nimport * as w from '../../warnings.js';\r\nimport { LOADING_ATTR_SYMBOL } from '../../constants.js';\r\nimport { queue_idle_task, queue_micro_task } from '../task.js';\r\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\r\n\r\n/**\r\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\r\n * to remove it upon hydration to avoid a bug when someone resets the form value.\r\n * @param {HTMLInputElement} input\r\n * @returns {void}\r\n */\r\nexport function remove_input_defaults(input) {\r\n\tif (!hydrating) return;\r\n\r\n\tvar already_removed = false;\r\n\r\n\t// We try and remove the default attributes later, rather than sync during hydration.\r\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\r\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\r\n\t// the idle callback, then we ensure the input defaults are cleared just before.\r\n\tvar remove_defaults = () => {\r\n\t\tif (already_removed) return;\r\n\t\talready_removed = true;\r\n\r\n\t\t// Remove the attributes but preserve the values\r\n\t\tif (input.hasAttribute('value')) {\r\n\t\t\tvar value = input.value;\r\n\t\t\tset_attribute(input, 'value', null);\r\n\t\t\tinput.value = value;\r\n\t\t}\r\n\r\n\t\tif (input.hasAttribute('checked')) {\r\n\t\t\tvar checked = input.checked;\r\n\t\t\tset_attribute(input, 'checked', null);\r\n\t\t\tinput.checked = checked;\r\n\t\t}\r\n\t};\r\n\r\n\t// @ts-expect-error\r\n\tinput.__on_r = remove_defaults;\r\n\tqueue_idle_task(remove_defaults);\r\n\tadd_form_reset_listener();\r\n}\r\n\r\n/**\r\n * @param {Element} element\r\n * @param {any} value\r\n */\r\nexport function set_value(element, value) {\r\n\t// @ts-expect-error\r\n\tvar attributes = (element.__attributes ??= {});\r\n\t// @ts-expect-error\r\n\tif (attributes.value === (attributes.value = value) || element.value === value) return;\r\n\t// @ts-expect-error\r\n\telement.value = value;\r\n}\r\n\r\n/**\r\n * @param {Element} element\r\n * @param {boolean} checked\r\n */\r\nexport function set_checked(element, checked) {\r\n\t// @ts-expect-error\r\n\tvar attributes = (element.__attributes ??= {});\r\n\r\n\tif (attributes.checked === (attributes.checked = checked)) return;\r\n\t// @ts-expect-error\r\n\telement.checked = checked;\r\n}\r\n\r\n/**\r\n * @param {Element} element\r\n * @param {string} attribute\r\n * @param {string | null} value\r\n * @param {boolean} [skip_warning]\r\n */\r\nexport function set_attribute(element, attribute, value, skip_warning) {\r\n\t// @ts-expect-error\r\n\tvar attributes = (element.__attributes ??= {});\r\n\r\n\tif (hydrating) {\r\n\t\tattributes[attribute] = element.getAttribute(attribute);\r\n\r\n\t\tif (\r\n\t\t\tattribute === 'src' ||\r\n\t\t\tattribute === 'srcset' ||\r\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\r\n\t\t) {\r\n\t\t\tif (!skip_warning) {\r\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\r\n\t\t\t}\r\n\r\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\r\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\r\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\r\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\r\n\r\n\tif (attribute === 'loading') {\r\n\t\t// @ts-expect-error\r\n\t\telement[LOADING_ATTR_SYMBOL] = value;\r\n\t}\r\n\r\n\tif (value == null) {\r\n\t\telement.removeAttribute(attribute);\r\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\r\n\t\t// @ts-ignore\r\n\t\telement[attribute] = value;\r\n\t} else {\r\n\t\telement.setAttribute(attribute, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Element} dom\r\n * @param {string} attribute\r\n * @param {string} value\r\n */\r\nexport function set_xlink_attribute(dom, attribute, value) {\r\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\r\n}\r\n\r\n/**\r\n * @param {any} node\r\n * @param {string} prop\r\n * @param {any} value\r\n */\r\nexport function set_custom_element_data(node, prop, value) {\r\n\tif (get_setters(node).includes(prop)) {\r\n\t\tnode[prop] = value;\r\n\t} else {\r\n\t\tset_attribute(node, prop, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\r\n * @param {Element & ElementCSSInlineStyle} element\r\n * @param {Record<string, any> | undefined} prev\r\n * @param {Record<string, any>} next New attributes - this function mutates this object\r\n * @param {string} [css_hash]\r\n * @param {boolean} [preserve_attribute_case]\r\n * @param {boolean} [is_custom_element]\r\n * @param {boolean} [skip_warning]\r\n * @returns {Record<string, any>}\r\n */\r\nexport function set_attributes(\r\n\telement,\r\n\tprev,\r\n\tnext,\r\n\tcss_hash,\r\n\tpreserve_attribute_case = false,\r\n\tis_custom_element = false,\r\n\tskip_warning = false\r\n) {\r\n\tvar current = prev || {};\r\n\tvar is_option_element = element.tagName === 'OPTION';\r\n\r\n\tfor (var key in prev) {\r\n\t\tif (!(key in next)) {\r\n\t\t\tnext[key] = null;\r\n\t\t}\r\n\t}\r\n\r\n\tif (css_hash !== undefined) {\r\n\t\tnext.class = next.class ? next.class + ' ' + css_hash : css_hash;\r\n\t}\r\n\r\n\tvar setters = get_setters(element);\r\n\r\n\t// @ts-expect-error\r\n\tvar attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});\r\n\t/** @type {Array<[string, any, () => void]>} */\r\n\tvar events = [];\r\n\r\n\t// since key is captured we use const\r\n\tfor (const key in next) {\r\n\t\t// let instead of var because referenced in a closure\r\n\t\tlet value = next[key];\r\n\r\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\r\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\r\n\t\tif (is_option_element && key === 'value' && value == null) {\r\n\t\t\t// The <option> element is a special case because removing the value attribute means\r\n\t\t\t// the value is set to the text content of the option element, and setting the value\r\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\r\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\r\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\r\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\r\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\r\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\r\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\r\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\r\n\t\t\t// @ts-ignore\r\n\t\t\telement.value = element.__value = '';\r\n\t\t\tcurrent[key] = value;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tvar prev_value = current[key];\r\n\t\tif (value === prev_value) continue;\r\n\r\n\t\tcurrent[key] = value;\r\n\r\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\r\n\t\tif (prefix === '$$') continue;\r\n\r\n\t\tif (prefix === 'on') {\r\n\t\t\t/** @type {{ capture?: true }} */\r\n\t\t\tconst opts = {};\r\n\t\t\tconst event_handle_key = '$$' + key;\r\n\t\t\tlet event_name = key.slice(2);\r\n\t\t\tvar delegated = is_delegated(event_name);\r\n\r\n\t\t\tif (is_capture_event(event_name)) {\r\n\t\t\t\tevent_name = event_name.slice(0, -7);\r\n\t\t\t\topts.capture = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (!delegated && prev_value) {\r\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\r\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\r\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\r\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\r\n\t\t\t\tif (value != null) continue;\r\n\r\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\r\n\t\t\t\tcurrent[event_handle_key] = null;\r\n\t\t\t}\r\n\r\n\t\t\tif (value != null) {\r\n\t\t\t\tif (!delegated) {\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @this {any}\r\n\t\t\t\t\t * @param {Event} evt\r\n\t\t\t\t\t */\r\n\t\t\t\t\tfunction handle(evt) {\r\n\t\t\t\t\t\tcurrent[key].call(this, evt);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!prev) {\r\n\t\t\t\t\t\tevents.push([\r\n\t\t\t\t\t\t\tkey,\r\n\t\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\t\t() => (current[event_handle_key] = create_event(event_name, element, handle, opts))\r\n\t\t\t\t\t\t]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\telement[`__${event_name}`] = value;\r\n\t\t\t\t\tdelegate([event_name]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (key === 'style' && value != null) {\r\n\t\t\telement.style.cssText = value + '';\r\n\t\t} else if (key === 'autofocus') {\r\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\r\n\t\t} else if (key === '__value' || (key === 'value' && value != null)) {\r\n\t\t\t// @ts-ignore\r\n\t\t\telement.value = element[key] = element.__value = value;\r\n\t\t} else {\r\n\t\t\tvar name = key;\r\n\t\t\tif (!preserve_attribute_case) {\r\n\t\t\t\tname = normalize_attribute(name);\r\n\t\t\t}\r\n\r\n\t\t\tif (value == null && !is_custom_element) {\r\n\t\t\t\tattributes[key] = null;\r\n\t\t\t\telement.removeAttribute(key);\r\n\t\t\t} else if (setters.includes(name) && (is_custom_element || typeof value !== 'string')) {\r\n\t\t\t\t// @ts-ignore\r\n\t\t\t\telement[name] = value;\r\n\t\t\t} else if (typeof value !== 'function') {\r\n\t\t\t\tif (hydrating && (name === 'src' || name === 'href' || name === 'srcset')) {\r\n\t\t\t\t\tif (!skip_warning) check_src_in_dev_hydration(element, name, value ?? '');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tset_attribute(element, name, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// On the first run, ensure that events are added after bindings so\r\n\t// that their listeners fire after the binding listeners\r\n\tif (!prev) {\r\n\t\tqueue_micro_task(() => {\r\n\t\t\tif (!element.isConnected) return;\r\n\t\t\tfor (const [key, value, evt] of events) {\r\n\t\t\t\tif (current[key] === value) {\r\n\t\t\t\t\tevt();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\treturn current;\r\n}\r\n\r\n/** @type {Map<string, string[]>} */\r\nvar setters_cache = new Map();\r\n\r\n/** @param {Element} element */\r\nfunction get_setters(element) {\r\n\tvar setters = setters_cache.get(element.nodeName);\r\n\tif (setters) return setters;\r\n\tsetters_cache.set(element.nodeName, (setters = []));\r\n\tvar descriptors;\r\n\tvar proto = get_prototype_of(element);\r\n\tvar element_proto = Element.prototype;\r\n\r\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\r\n\t// Do not use contructor.name here as that's unreliable in some browser environments\r\n\twhile (element_proto !== proto) {\r\n\t\tdescriptors = get_descriptors(proto);\r\n\r\n\t\tfor (var key in descriptors) {\r\n\t\t\tif (descriptors[key].set) {\r\n\t\t\t\tsetters.push(key);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tproto = get_prototype_of(proto);\r\n\t}\r\n\r\n\treturn setters;\r\n}\r\n\r\n/**\r\n * @param {any} element\r\n * @param {string} attribute\r\n * @param {string} value\r\n */\r\nfunction check_src_in_dev_hydration(element, attribute, value) {\r\n\tif (!DEV) return;\r\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\r\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\r\n\r\n\tw.hydration_attribute_changed(\r\n\t\tattribute,\r\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\r\n\t\tString(value)\r\n\t);\r\n}\r\n\r\n/**\r\n * @param {string} element_src\r\n * @param {string} url\r\n * @returns {boolean}\r\n */\r\nfunction src_url_equal(element_src, url) {\r\n\tif (element_src === url) return true;\r\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\r\n}\r\n\r\n/** @param {string} srcset */\r\nfunction split_srcset(srcset) {\r\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\r\n}\r\n\r\n/**\r\n * @param {HTMLSourceElement | HTMLImageElement} element\r\n * @param {string} srcset\r\n * @returns {boolean}\r\n */\r\nfunction srcset_url_equal(element, srcset) {\r\n\tvar element_urls = split_srcset(element.srcset);\r\n\tvar urls = split_srcset(srcset);\r\n\r\n\treturn (\r\n\t\turls.length === element_urls.length &&\r\n\t\turls.every(\r\n\t\t\t([url, width], i) =>\r\n\t\t\t\twidth === element_urls[i][1] &&\r\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\r\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\r\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\r\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\r\n\t\t\t\t// contain relative or absolute URLs.\r\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\r\n\t\t)\r\n\t);\r\n}\r\n\r\n/**\r\n * @param {HTMLImageElement} element\r\n * @returns {void}\r\n */\r\nexport function handle_lazy_img(element) {\r\n\t// If we're using an image that has a lazy loading attribute, we need to apply\r\n\t// the loading and src after the img element has been appended to the document.\r\n\t// Otherwise the lazy behaviour will not work due to our cloneNode heuristic for\r\n\t// templates.\r\n\tif (!hydrating && element.loading === 'lazy') {\r\n\t\tvar src = element.src;\r\n\t\t// @ts-expect-error\r\n\t\telement[LOADING_ATTR_SYMBOL] = null;\r\n\t\telement.loading = 'eager';\r\n\t\telement.removeAttribute('src');\r\n\t\trequestAnimationFrame(() => {\r\n\t\t\t// @ts-expect-error\r\n\t\t\tif (element[LOADING_ATTR_SYMBOL] !== 'eager') {\r\n\t\t\t\telement.loading = 'lazy';\r\n\t\t\t}\r\n\t\t\telement.src = src;\r\n\t\t});\r\n\t}\r\n}\r\n", "import { effect, teardown } from '../../../reactivity/effects.js';\r\nimport { untrack } from '../../../runtime.js';\r\n\r\n/**\r\n * Resize observer singleton.\r\n * One listener per element only!\r\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\r\n */\r\nclass ResizeObserverSingleton {\r\n\t/** */\r\n\t#listeners = new WeakMap();\r\n\r\n\t/** @type {ResizeObserver | undefined} */\r\n\t#observer;\r\n\r\n\t/** @type {ResizeObserverOptions} */\r\n\t#options;\r\n\r\n\t/** @static */\r\n\tstatic entries = new WeakMap();\r\n\r\n\t/** @param {ResizeObserverOptions} options */\r\n\tconstructor(options) {\r\n\t\tthis.#options = options;\r\n\t}\r\n\r\n\t/**\r\n\t * @param {Element} element\r\n\t * @param {(entry: ResizeObserverEntry) => any} listener\r\n\t */\r\n\tobserve(element, listener) {\r\n\t\tvar listeners = this.#listeners.get(element) || new Set();\r\n\t\tlisteners.add(listener);\r\n\r\n\t\tthis.#listeners.set(element, listeners);\r\n\t\tthis.#getObserver().observe(element, this.#options);\r\n\r\n\t\treturn () => {\r\n\t\t\tvar listeners = this.#listeners.get(element);\r\n\t\t\tlisteners.delete(listener);\r\n\r\n\t\t\tif (listeners.size === 0) {\r\n\t\t\t\tthis.#listeners.delete(element);\r\n\t\t\t\t/** @type {ResizeObserver} */ (this.#observer).unobserve(element);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t#getObserver() {\r\n\t\treturn (\r\n\t\t\tthis.#observer ??\r\n\t\t\t(this.#observer = new ResizeObserver(\r\n\t\t\t\t/** @param {any} entries */ (entries) => {\r\n\t\t\t\t\tfor (var entry of entries) {\r\n\t\t\t\t\t\tResizeObserverSingleton.entries.set(entry.target, entry);\r\n\t\t\t\t\t\tfor (var listener of this.#listeners.get(entry.target) || []) {\r\n\t\t\t\t\t\t\tlistener(entry);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t))\r\n\t\t);\r\n\t}\r\n}\r\n\r\nvar resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\r\n\tbox: 'content-box'\r\n});\r\n\r\nvar resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\r\n\tbox: 'border-box'\r\n});\r\n\r\nvar resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\r\n\tbox: 'device-pixel-content-box'\r\n});\r\n\r\n/**\r\n * @param {Element} element\r\n * @param {'contentRect' | 'contentBoxSize' | 'borderBoxSize' | 'devicePixelContentBoxSize'} type\r\n * @param {(entry: keyof ResizeObserverEntry) => void} set\r\n */\r\nexport function bind_resize_observer(element, type, set) {\r\n\tvar observer =\r\n\t\ttype === 'contentRect' || type === 'contentBoxSize'\r\n\t\t\t? resize_observer_content_box\r\n\t\t\t: type === 'borderBoxSize'\r\n\t\t\t\t? resize_observer_border_box\r\n\t\t\t\t: resize_observer_device_pixel_content_box;\r\n\r\n\tvar unsub = observer.observe(element, /** @param {any} entry */ (entry) => set(entry[type]));\r\n\tteardown(unsub);\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} element\r\n * @param {'clientWidth' | 'clientHeight' | 'offsetWidth' | 'offsetHeight'} type\r\n * @param {(size: number) => void} set\r\n */\r\nexport function bind_element_size(element, type, set) {\r\n\tvar unsub = resize_observer_border_box.observe(element, () => set(element[type]));\r\n\r\n\teffect(() => {\r\n\t\t// The update could contain reads which should be ignored\r\n\t\tuntrack(() => set(element[type]));\r\n\t\treturn unsub;\r\n\t});\r\n}\r\n", "/** @import { ComponentContextLegacy } from '#client' */\r\nimport { run, run_all } from '../../../shared/utils.js';\r\nimport { derived } from '../../reactivity/deriveds.js';\r\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\r\nimport { component_context, deep_read_state, get, untrack } from '../../runtime.js';\r\n\r\n/**\r\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\r\n * @param {boolean} [immutable]\r\n */\r\nexport function init(immutable = false) {\r\n\tconst context = /** @type {ComponentContextLegacy} */ (component_context);\r\n\r\n\tconst callbacks = context.l.u;\r\n\tif (!callbacks) return;\r\n\r\n\tlet props = () => deep_read_state(context.s);\r\n\r\n\tif (immutable) {\r\n\t\tlet version = 0;\r\n\t\tlet prev = /** @type {Record<string, any>} */ ({});\r\n\r\n\t\t// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes\r\n\t\tconst d = derived(() => {\r\n\t\t\tlet changed = false;\r\n\t\t\tconst props = context.s;\r\n\t\t\tfor (const key in props) {\r\n\t\t\t\tif (props[key] !== prev[key]) {\r\n\t\t\t\t\tprev[key] = props[key];\r\n\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (changed) version++;\r\n\t\t\treturn version;\r\n\t\t});\r\n\r\n\t\tprops = () => get(d);\r\n\t}\r\n\r\n\t// beforeUpdate\r\n\tif (callbacks.b.length) {\r\n\t\tuser_pre_effect(() => {\r\n\t\t\tobserve_all(context, props);\r\n\t\t\trun_all(callbacks.b);\r\n\t\t});\r\n\t}\r\n\r\n\t// onMount (must run before afterUpdate)\r\n\tuser_effect(() => {\r\n\t\tconst fns = untrack(() => callbacks.m.map(run));\r\n\t\treturn () => {\r\n\t\t\tfor (const fn of fns) {\r\n\t\t\t\tif (typeof fn === 'function') {\r\n\t\t\t\t\tfn();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t});\r\n\r\n\t// afterUpdate\r\n\tif (callbacks.a.length) {\r\n\t\tuser_effect(() => {\r\n\t\t\tobserve_all(context, props);\r\n\t\t\trun_all(callbacks.a);\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * Invoke the getter of all signals associated with a component\r\n * so they can be registered to the effect this function is called in.\r\n * @param {ComponentContextLegacy} context\r\n * @param {(() => void)} props\r\n */\r\nfunction observe_all(context, props) {\r\n\tif (context.l.s) {\r\n\t\tfor (const signal of context.l.s) get(signal);\r\n\t}\r\n\r\n\tprops();\r\n}\r\n", "/** @import { Derived, Source } from './types.js' */\r\nimport { DEV } from 'esm-env';\r\nimport {\r\n\tPROPS_IS_BINDABLE,\r\n\tPROPS_IS_IMMUTABLE,\r\n\tPROPS_IS_LAZY_INITIAL,\r\n\tPROPS_IS_RUNES,\r\n\tPROPS_IS_UPDATED\r\n} from '../../../constants.js';\r\nimport { get_descriptor, is_function } from '../../shared/utils.js';\r\nimport { mutable_source, set, source } from './sources.js';\r\nimport { derived, derived_safe_equal } from './deriveds.js';\r\nimport {\r\n\tactive_effect,\r\n\tactive_reaction,\r\n\tget,\r\n\tis_signals_recorded,\r\n\tset_active_effect,\r\n\tuntrack,\r\n\tupdate\r\n} from '../runtime.js';\r\nimport { safe_equals } from './equality.js';\r\nimport * as e from '../errors.js';\r\nimport { BRANCH_EFFECT, DESTROYED, LEGACY_DERIVED_PROP, ROOT_EFFECT } from '../constants.js';\r\nimport { proxy } from '../proxy.js';\r\n\r\n/**\r\n * @param {((value?: number) => number)} fn\r\n * @param {1 | -1} [d]\r\n * @returns {number}\r\n */\r\nexport function update_prop(fn, d = 1) {\r\n\tconst value = fn();\r\n\tfn(value + d);\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * @param {((value?: number) => number)} fn\r\n * @param {1 | -1} [d]\r\n * @returns {number}\r\n */\r\nexport function update_pre_prop(fn, d = 1) {\r\n\tconst value = fn() + d;\r\n\tfn(value);\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\r\n * Is passed the full `$$props` object and excludes the named props.\r\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\r\n */\r\nconst rest_props_handler = {\r\n\tget(target, key) {\r\n\t\tif (target.exclude.includes(key)) return;\r\n\t\treturn target.props[key];\r\n\t},\r\n\tset(target, key) {\r\n\t\tif (DEV) {\r\n\t\t\t// TODO should this happen in prod too?\r\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\tgetOwnPropertyDescriptor(target, key) {\r\n\t\tif (target.exclude.includes(key)) return;\r\n\t\tif (key in target.props) {\r\n\t\t\treturn {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tvalue: target.props[key]\r\n\t\t\t};\r\n\t\t}\r\n\t},\r\n\thas(target, key) {\r\n\t\tif (target.exclude.includes(key)) return false;\r\n\t\treturn key in target.props;\r\n\t},\r\n\townKeys(target) {\r\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {Record<string, unknown>} props\r\n * @param {string[]} exclude\r\n * @param {string} [name]\r\n * @returns {Record<string, unknown>}\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function rest_props(props, exclude, name) {\r\n\treturn new Proxy(\r\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\r\n\t\trest_props_handler\r\n\t);\r\n}\r\n\r\n/**\r\n * The proxy handler for legacy $$restProps and $$props\r\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\r\n */\r\nconst legacy_rest_props_handler = {\r\n\tget(target, key) {\r\n\t\tif (target.exclude.includes(key)) return;\r\n\t\tget(target.version);\r\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\r\n\t},\r\n\tset(target, key, value) {\r\n\t\tif (!(key in target.special)) {\r\n\t\t\t// Handle props that can temporarily get out of sync with the parent\r\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\r\n\t\t\ttarget.special[key] = prop(\r\n\t\t\t\t{\r\n\t\t\t\t\tget [key]() {\r\n\t\t\t\t\t\treturn target.props[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t/** @type {string} */ (key),\r\n\t\t\t\tPROPS_IS_UPDATED\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\ttarget.special[key](value);\r\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\r\n\t\treturn true;\r\n\t},\r\n\tgetOwnPropertyDescriptor(target, key) {\r\n\t\tif (target.exclude.includes(key)) return;\r\n\t\tif (key in target.props) {\r\n\t\t\treturn {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tconfigurable: true,\r\n\t\t\t\tvalue: target.props[key]\r\n\t\t\t};\r\n\t\t}\r\n\t},\r\n\tdeleteProperty(target, key) {\r\n\t\t// Svelte 4 allowed for deletions on $$restProps\r\n\t\tif (target.exclude.includes(key)) return true;\r\n\t\ttarget.exclude.push(key);\r\n\t\tupdate(target.version);\r\n\t\treturn true;\r\n\t},\r\n\thas(target, key) {\r\n\t\tif (target.exclude.includes(key)) return false;\r\n\t\treturn key in target.props;\r\n\t},\r\n\townKeys(target) {\r\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {Record<string, unknown>} props\r\n * @param {string[]} exclude\r\n * @returns {Record<string, unknown>}\r\n */\r\nexport function legacy_rest_props(props, exclude) {\r\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\r\n}\r\n\r\n/**\r\n * The proxy handler for spread props. Handles the incoming array of props\r\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\r\n * them so that the whole thing is passed to the component as the `$$props` argument.\r\n * @template {Record<string | symbol, unknown>} T\r\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\r\n */\r\nconst spread_props_handler = {\r\n\tget(target, key) {\r\n\t\tlet i = target.props.length;\r\n\t\twhile (i--) {\r\n\t\t\tlet p = target.props[i];\r\n\t\t\tif (is_function(p)) p = p();\r\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\r\n\t\t}\r\n\t},\r\n\tgetOwnPropertyDescriptor(target, key) {\r\n\t\tlet i = target.props.length;\r\n\t\twhile (i--) {\r\n\t\t\tlet p = target.props[i];\r\n\t\t\tif (is_function(p)) p = p();\r\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\r\n\t\t\t\tconst descriptor = get_descriptor(p, key);\r\n\t\t\t\tif (descriptor && !descriptor.configurable) {\r\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\r\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\r\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\r\n\t\t\t\t\tdescriptor.configurable = true;\r\n\t\t\t\t}\r\n\t\t\t\treturn descriptor;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\thas(target, key) {\r\n\t\tfor (let p of target.props) {\r\n\t\t\tif (is_function(p)) p = p();\r\n\t\t\tif (p != null && key in p) return true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\townKeys(target) {\r\n\t\t/** @type {Array<string | symbol>} */\r\n\t\tconst keys = [];\r\n\r\n\t\tfor (let p of target.props) {\r\n\t\t\tif (is_function(p)) p = p();\r\n\t\t\tfor (const key in p) {\r\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn keys;\r\n\t}\r\n};\r\n\r\n/**\r\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\r\n * @returns {any}\r\n */\r\nexport function spread_props(...props) {\r\n\treturn new Proxy({ props }, spread_props_handler);\r\n}\r\n\r\n/**\r\n * @template T\r\n * @param {() => T} fn\r\n * @returns {T}\r\n */\r\nfunction with_parent_branch(fn) {\r\n\tvar effect = active_effect;\r\n\tvar previous_effect = active_effect;\r\n\r\n\twhile (effect !== null && (effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {\r\n\t\teffect = effect.parent;\r\n\t}\r\n\ttry {\r\n\t\tset_active_effect(effect);\r\n\t\treturn fn();\r\n\t} finally {\r\n\t\tset_active_effect(previous_effect);\r\n\t}\r\n}\r\n\r\n/**\r\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\r\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\r\n * @template V\r\n * @param {Record<string, unknown>} props\r\n * @param {string} key\r\n * @param {number} flags\r\n * @param {V | (() => V)} [fallback]\r\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\r\n */\r\nexport function prop(props, key, flags, fallback) {\r\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\r\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\r\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\r\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\r\n\r\n\tvar prop_value = /** @type {V} */ (props[key]);\r\n\tvar setter = get_descriptor(props, key)?.set;\r\n\r\n\tvar fallback_value = /** @type {V} */ (fallback);\r\n\tvar fallback_dirty = true;\r\n\tvar fallback_used = false;\r\n\r\n\tvar get_fallback = () => {\r\n\t\tfallback_used = true;\r\n\t\tif (fallback_dirty) {\r\n\t\t\tfallback_dirty = false;\r\n\t\t\tif (lazy) {\r\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\r\n\t\t\t} else {\r\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn fallback_value;\r\n\t};\r\n\r\n\tif (prop_value === undefined && fallback !== undefined) {\r\n\t\tif (setter && runes) {\r\n\t\t\te.props_invalid_value(key);\r\n\t\t}\r\n\r\n\t\tprop_value = get_fallback();\r\n\t\tif (setter) setter(prop_value);\r\n\t}\r\n\r\n\t/** @type {() => V} */\r\n\tvar getter;\r\n\tif (runes) {\r\n\t\tgetter = () => {\r\n\t\t\tvar value = /** @type {V} */ (props[key]);\r\n\t\t\tif (value === undefined) return get_fallback();\r\n\t\t\tfallback_dirty = true;\r\n\t\t\tfallback_used = false;\r\n\t\t\treturn value;\r\n\t\t};\r\n\t} else {\r\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\r\n\t\t// Replicate that behavior through using a derived\r\n\t\tvar derived_getter = with_parent_branch(() =>\r\n\t\t\t(immutable ? derived : derived_safe_equal)(() => /** @type {V} */ (props[key]))\r\n\t\t);\r\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\r\n\t\tgetter = () => {\r\n\t\t\tvar value = get(derived_getter);\r\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\r\n\t\t\treturn value === undefined ? fallback_value : value;\r\n\t\t};\r\n\t}\r\n\r\n\t// easy mode — prop is never written to\r\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\r\n\t\treturn getter;\r\n\t}\r\n\r\n\t// intermediate mode — prop is written to, but the parent component had\r\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\r\n\tif (setter) {\r\n\t\tvar legacy_parent = props.$$legacy;\r\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\r\n\t\t\tif (arguments.length > 0) {\r\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\r\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\r\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\r\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\r\n\t\t\t\tif (!runes || !mutation || legacy_parent) {\r\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t} else {\r\n\t\t\t\treturn getter();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\t// hard mode. this is where it gets ugly — the value in the child should\r\n\t// synchronize with the parent, but it should also be possible to temporarily\r\n\t// set the value to something else locally.\r\n\tvar from_child = false;\r\n\tvar was_from_child = false;\r\n\r\n\t// The derived returns the current value. The underlying mutable\r\n\t// source is written to from various places to persist this value.\r\n\tvar inner_current_value = mutable_source(prop_value);\r\n\r\n\tvar current_value = with_parent_branch(() =>\r\n\t\tderived(() => {\r\n\t\t\tvar parent_value = getter();\r\n\t\t\tvar child_value = get(inner_current_value);\r\n\t\t\tvar current_derived = /** @type {Derived} */ (active_reaction);\r\n\r\n\t\t\t// If the getter from the parent returns undefined, switch\r\n\t\t\t// to using the local value from inner_current_value instead,\r\n\t\t\t// as the parent value might have been torn down\r\n\t\t\tif (from_child || (parent_value === undefined && (current_derived.f & DESTROYED) !== 0)) {\r\n\t\t\t\tfrom_child = false;\r\n\t\t\t\twas_from_child = true;\r\n\t\t\t\treturn child_value;\r\n\t\t\t}\r\n\r\n\t\t\twas_from_child = false;\r\n\t\t\treturn (inner_current_value.v = parent_value);\r\n\t\t})\r\n\t);\r\n\r\n\tif (!immutable) current_value.equals = safe_equals;\r\n\r\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\r\n\t\tvar current = get(current_value);\r\n\r\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\r\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\r\n\t\tif (is_signals_recorded) {\r\n\t\t\t// set this so that we don't reset to the parent value if `d`\r\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\r\n\t\t\t// than because the parent or child value changed)\r\n\t\t\tfrom_child = was_from_child;\r\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\r\n\t\t\tgetter();\r\n\t\t\tget(inner_current_value);\r\n\t\t}\r\n\r\n\t\tif (arguments.length > 0) {\r\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\r\n\r\n\t\t\tif (!current_value.equals(new_value)) {\r\n\t\t\t\tfrom_child = true;\r\n\t\t\t\tset(inner_current_value, new_value);\r\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\r\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\r\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\r\n\t\t\t\t\tfallback_value = new_value;\r\n\t\t\t\t}\r\n\t\t\t\tget(current_value); // force a synchronisation immediately\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\treturn current;\r\n\t};\r\n}\r\n", "import { createClassComponent } from '../../../../legacy/legacy-client.js';\r\nimport { destroy_effect, effect_root, render_effect } from '../../reactivity/effects.js';\r\nimport { append } from '../template.js';\r\nimport { define_property, get_descriptor, object_keys } from '../../../shared/utils.js';\r\n\r\n/**\r\n * @typedef {Object} CustomElementPropDefinition\r\n * @property {string} [attribute]\r\n * @property {boolean} [reflect]\r\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\r\n */\r\n\r\n/** @type {any} */\r\nlet SvelteElement;\r\n\r\nif (typeof HTMLElement === 'function') {\r\n\tSvelteElement = class extends HTMLElement {\r\n\t\t/** The Svelte component constructor */\r\n\t\t$$ctor;\r\n\t\t/** Slots */\r\n\t\t$$s;\r\n\t\t/** @type {any} The Svelte component instance */\r\n\t\t$$c;\r\n\t\t/** Whether or not the custom element is connected */\r\n\t\t$$cn = false;\r\n\t\t/** @type {Record<string, any>} Component props data */\r\n\t\t$$d = {};\r\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\r\n\t\t$$r = false;\r\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\r\n\t\t$$p_d = {};\r\n\t\t/** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */\r\n\t\t$$l = {};\r\n\t\t/** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */\r\n\t\t$$l_u = new Map();\r\n\t\t/** @type {any} The managed render effect for reflecting attributes */\r\n\t\t$$me;\r\n\r\n\t\t/**\r\n\t\t * @param {*} $$componentCtor\r\n\t\t * @param {*} $$slots\r\n\t\t * @param {*} use_shadow_dom\r\n\t\t */\r\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\r\n\t\t\tsuper();\r\n\t\t\tthis.$$ctor = $$componentCtor;\r\n\t\t\tthis.$$s = $$slots;\r\n\t\t\tif (use_shadow_dom) {\r\n\t\t\t\tthis.attachShadow({ mode: 'open' });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @param {string} type\r\n\t\t * @param {EventListenerOrEventListenerObject} listener\r\n\t\t * @param {boolean | AddEventListenerOptions} [options]\r\n\t\t */\r\n\t\taddEventListener(type, listener, options) {\r\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\r\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\r\n\t\t\t// browser event, this fires twice - we can't avoid that.\r\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\r\n\t\t\tthis.$$l[type].push(listener);\r\n\t\t\tif (this.$$c) {\r\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\r\n\t\t\t\tthis.$$l_u.set(listener, unsub);\r\n\t\t\t}\r\n\t\t\tsuper.addEventListener(type, listener, options);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @param {string} type\r\n\t\t * @param {EventListenerOrEventListenerObject} listener\r\n\t\t * @param {boolean | AddEventListenerOptions} [options]\r\n\t\t */\r\n\t\tremoveEventListener(type, listener, options) {\r\n\t\t\tsuper.removeEventListener(type, listener, options);\r\n\t\t\tif (this.$$c) {\r\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\r\n\t\t\t\tif (unsub) {\r\n\t\t\t\t\tunsub();\r\n\t\t\t\t\tthis.$$l_u.delete(listener);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tasync connectedCallback() {\r\n\t\t\tthis.$$cn = true;\r\n\t\t\tif (!this.$$c) {\r\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\r\n\t\t\t\tawait Promise.resolve();\r\n\t\t\t\tif (!this.$$cn || this.$$c) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t/** @param {string} name */\r\n\t\t\t\tfunction create_slot(name) {\r\n\t\t\t\t\t/**\r\n\t\t\t\t\t * @param {Element} anchor\r\n\t\t\t\t\t */\r\n\t\t\t\t\treturn (anchor) => {\r\n\t\t\t\t\t\tconst slot = document.createElement('slot');\r\n\t\t\t\t\t\tif (name !== 'default') slot.name = name;\r\n\r\n\t\t\t\t\t\tappend(anchor, slot);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\t/** @type {Record<string, any>} */\r\n\t\t\t\tconst $$slots = {};\r\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\r\n\t\t\t\tfor (const name of this.$$s) {\r\n\t\t\t\t\tif (name in existing_slots) {\r\n\t\t\t\t\t\tif (name === 'default' && !this.$$d.children) {\r\n\t\t\t\t\t\t\tthis.$$d.children = create_slot(name);\r\n\t\t\t\t\t\t\t$$slots.default = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t$$slots[name] = create_slot(name);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor (const attribute of this.attributes) {\r\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\r\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\r\n\t\t\t\t\tif (!(name in this.$$d)) {\r\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\r\n\t\t\t\tfor (const key in this.$$p_d) {\r\n\t\t\t\t\t// @ts-expect-error\r\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\r\n\t\t\t\t\t\t// @ts-expect-error\r\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\r\n\t\t\t\t\t\t// @ts-expect-error\r\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.$$c = createClassComponent({\r\n\t\t\t\t\tcomponent: this.$$ctor,\r\n\t\t\t\t\ttarget: this.shadowRoot || this,\r\n\t\t\t\t\tprops: {\r\n\t\t\t\t\t\t...this.$$d,\r\n\t\t\t\t\t\t$$slots,\r\n\t\t\t\t\t\t$$host: this\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Reflect component props as attributes\r\n\t\t\t\tthis.$$me = effect_root(() => {\r\n\t\t\t\t\trender_effect(() => {\r\n\t\t\t\t\t\tthis.$$r = true;\r\n\t\t\t\t\t\tfor (const key of object_keys(this.$$c)) {\r\n\t\t\t\t\t\t\tif (!this.$$p_d[key]?.reflect) continue;\r\n\t\t\t\t\t\t\tthis.$$d[key] = this.$$c[key];\r\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\r\n\t\t\t\t\t\t\t\tkey,\r\n\t\t\t\t\t\t\t\tthis.$$d[key],\r\n\t\t\t\t\t\t\t\tthis.$$p_d,\r\n\t\t\t\t\t\t\t\t'toAttribute'\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif (attribute_value == null) {\r\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.$$r = false;\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\tfor (const type in this.$$l) {\r\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\r\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\r\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.$$l = {};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\r\n\t\t// and setting attributes through setAttribute etc, this is helpful\r\n\r\n\t\t/**\r\n\t\t * @param {string} attr\r\n\t\t * @param {string} _oldValue\r\n\t\t * @param {string} newValue\r\n\t\t */\r\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\r\n\t\t\tif (this.$$r) return;\r\n\t\t\tattr = this.$$g_p(attr);\r\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\r\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\r\n\t\t}\r\n\r\n\t\tdisconnectedCallback() {\r\n\t\t\tthis.$$cn = false;\r\n\t\t\t// In a microtask, because this could be a move within the DOM\r\n\t\t\tPromise.resolve().then(() => {\r\n\t\t\t\tif (!this.$$cn && this.$$c) {\r\n\t\t\t\t\tthis.$$c.$destroy();\r\n\t\t\t\t\tthis.$$me();\r\n\t\t\t\t\tthis.$$c = undefined;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * @param {string} attribute_name\r\n\t\t */\r\n\t\t$$g_p(attribute_name) {\r\n\t\t\treturn (\r\n\t\t\t\tobject_keys(this.$$p_d).find(\r\n\t\t\t\t\t(key) =>\r\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\r\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\r\n\t\t\t\t) || attribute_name\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {string} prop\r\n * @param {any} value\r\n * @param {Record<string, CustomElementPropDefinition>} props_definition\r\n * @param {'toAttribute' | 'toProp'} [transform]\r\n */\r\nfunction get_custom_element_value(prop, value, props_definition, transform) {\r\n\tconst type = props_definition[prop]?.type;\r\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\r\n\tif (!transform || !props_definition[prop]) {\r\n\t\treturn value;\r\n\t} else if (transform === 'toAttribute') {\r\n\t\tswitch (type) {\r\n\t\t\tcase 'Object':\r\n\t\t\tcase 'Array':\r\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\r\n\t\t\tcase 'Boolean':\r\n\t\t\t\treturn value ? '' : null;\r\n\t\t\tcase 'Number':\r\n\t\t\t\treturn value == null ? null : value;\r\n\t\t\tdefault:\r\n\t\t\t\treturn value;\r\n\t\t}\r\n\t} else {\r\n\t\tswitch (type) {\r\n\t\t\tcase 'Object':\r\n\t\t\tcase 'Array':\r\n\t\t\t\treturn value && JSON.parse(value);\r\n\t\t\tcase 'Boolean':\r\n\t\t\t\treturn value; // conversion already handled above\r\n\t\t\tcase 'Number':\r\n\t\t\t\treturn value != null ? +value : value;\r\n\t\t\tdefault:\r\n\t\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {HTMLElement} element\r\n */\r\nfunction get_custom_elements_slots(element) {\r\n\t/** @type {Record<string, true>} */\r\n\tconst result = {};\r\n\telement.childNodes.forEach((node) => {\r\n\t\tresult[/** @type {Element} node */ (node).slot || 'default'] = true;\r\n\t});\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * @internal\r\n *\r\n * Turn a Svelte component into a custom element.\r\n * @param {any} Component  A Svelte component function\r\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\r\n * @param {string[]} slots  The slots to create\r\n * @param {string[]} exports  Explicitly exported values, other than props\r\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\r\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\r\n */\r\nexport function create_custom_element(\r\n\tComponent,\r\n\tprops_definition,\r\n\tslots,\r\n\texports,\r\n\tuse_shadow_dom,\r\n\textend\r\n) {\r\n\tlet Class = class extends SvelteElement {\r\n\t\tconstructor() {\r\n\t\t\tsuper(Component, slots, use_shadow_dom);\r\n\t\t\tthis.$$p_d = props_definition;\r\n\t\t}\r\n\t\tstatic get observedAttributes() {\r\n\t\t\treturn object_keys(props_definition).map((key) =>\r\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n\tobject_keys(props_definition).forEach((prop) => {\r\n\t\tdefine_property(Class.prototype, prop, {\r\n\t\t\tget() {\r\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\r\n\t\t\t\tthis.$$d[prop] = value;\r\n\t\t\t\tvar component = this.$$c;\r\n\r\n\t\t\t\tif (component) {\r\n\t\t\t\t\t// // If the instance has an accessor, use that instead\r\n\t\t\t\t\tvar setter = get_descriptor(component, prop)?.get;\r\n\r\n\t\t\t\t\tif (setter) {\r\n\t\t\t\t\t\tcomponent[prop] = value;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcomponent.$set({ [prop]: value });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\texports.forEach((property) => {\r\n\t\tdefine_property(Class.prototype, property, {\r\n\t\t\tget() {\r\n\t\t\t\treturn this.$$c?.[property];\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\tif (extend) {\r\n\t\t// @ts-expect-error - assigning here is fine\r\n\t\tClass = extend(Class);\r\n\t}\r\n\tComponent.element = /** @type {any} */ Class;\r\n\treturn Class;\r\n}\r\n"],
  "mappings": "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",
  "names": ["component", "snippet", "element", "html", "element", "comment", "component", "_a", "state", "i", "fallback", "_a", "index", "next", "element", "effect", "element", "element", "next", "key", "element", "listeners", "props", "effect", "fallback", "slot", "prop", "element"]
}
