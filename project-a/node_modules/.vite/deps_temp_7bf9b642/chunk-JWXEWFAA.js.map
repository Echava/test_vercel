{
  "version": 3,
  "sources": ["../../svelte/src/internal/client/dom/elements/events.js", "../../svelte/src/internal/client/dom/blocks/svelte-head.js", "../../svelte/src/internal/client/dom/reconciler.js", "../../svelte/src/internal/client/dom/template.js", "../../svelte/src/internal/client/render.js", "../../svelte/src/internal/client/dom/legacy/event-modifiers.js", "../../svelte/src/legacy/legacy-client.js"],
  "sourcesContent": ["/** @import { Location } from 'locate-character' */\r\nimport { teardown } from '../../reactivity/effects.js';\r\nimport { define_property, is_array } from '../../../shared/utils.js';\r\nimport { hydrating } from '../hydration.js';\r\nimport { queue_micro_task } from '../task.js';\r\nimport { FILENAME } from '../../../../constants.js';\r\nimport * as w from '../../warnings.js';\r\nimport {\r\n\tactive_effect,\r\n\tactive_reaction,\r\n\tset_active_effect,\r\n\tset_active_reaction\r\n} from '../../runtime.js';\r\n\r\n/** @type {Set<string>} */\r\nexport const all_registered_events = new Set();\r\n\r\n/** @type {Set<(events: Array<string>) => void>} */\r\nexport const root_event_handles = new Set();\r\n\r\n/**\r\n * SSR adds onload and onerror attributes to catch those events before the hydration.\r\n * This function detects those cases, removes the attributes and replays the events.\r\n * @param {HTMLElement} dom\r\n */\r\nexport function replay_events(dom) {\r\n\tif (!hydrating) return;\r\n\r\n\tif (dom.onload) {\r\n\t\tdom.removeAttribute('onload');\r\n\t}\r\n\tif (dom.onerror) {\r\n\t\tdom.removeAttribute('onerror');\r\n\t}\r\n\t// @ts-expect-error\r\n\tconst event = dom.__e;\r\n\tif (event !== undefined) {\r\n\t\t// @ts-expect-error\r\n\t\tdom.__e = undefined;\r\n\t\tqueueMicrotask(() => {\r\n\t\t\tif (dom.isConnected) {\r\n\t\t\t\tdom.dispatchEvent(event);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {string} event_name\r\n * @param {EventTarget} dom\r\n * @param {EventListener} handler\r\n * @param {AddEventListenerOptions} options\r\n */\r\nexport function create_event(event_name, dom, handler, options) {\r\n\t/**\r\n\t * @this {EventTarget}\r\n\t */\r\n\tfunction target_handler(/** @type {Event} */ event) {\r\n\t\tif (!options.capture) {\r\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\r\n\t\t\thandle_event_propagation.call(dom, event);\r\n\t\t}\r\n\t\tif (!event.cancelBubble) {\r\n\t\t\tvar previous_reaction = active_reaction;\r\n\t\t\tvar previous_effect = active_effect;\r\n\r\n\t\t\tset_active_reaction(null);\r\n\t\t\tset_active_effect(null);\r\n\t\t\ttry {\r\n\t\t\t\treturn handler.call(this, event);\r\n\t\t\t} finally {\r\n\t\t\t\tset_active_reaction(previous_reaction);\r\n\t\t\t\tset_active_effect(previous_effect);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\r\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\r\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\r\n\t// this bug. The same applies to wheel events and touch events.\r\n\tif (\r\n\t\tevent_name.startsWith('pointer') ||\r\n\t\tevent_name.startsWith('touch') ||\r\n\t\tevent_name === 'wheel'\r\n\t) {\r\n\t\tqueue_micro_task(() => {\r\n\t\t\tdom.addEventListener(event_name, target_handler, options);\r\n\t\t});\r\n\t} else {\r\n\t\tdom.addEventListener(event_name, target_handler, options);\r\n\t}\r\n\r\n\treturn target_handler;\r\n}\r\n\r\n/**\r\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\r\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\r\n * (with attributes like `onclick`), which use event delegation for performance reasons\r\n *\r\n * @param {EventTarget} element\r\n * @param {string} type\r\n * @param {EventListener} handler\r\n * @param {AddEventListenerOptions} [options]\r\n */\r\nexport function on(element, type, handler, options = {}) {\r\n\tvar target_handler = create_event(type, element, handler, options);\r\n\r\n\treturn () => {\r\n\t\telement.removeEventListener(type, target_handler, options);\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {string} event_name\r\n * @param {Element} dom\r\n * @param {EventListener} handler\r\n * @param {boolean} capture\r\n * @param {boolean} [passive]\r\n * @returns {void}\r\n */\r\nexport function event(event_name, dom, handler, capture, passive) {\r\n\tvar options = { capture, passive };\r\n\tvar target_handler = create_event(event_name, dom, handler, options);\r\n\r\n\t// @ts-ignore\r\n\tif (dom === document.body || dom === window || dom === document) {\r\n\t\tteardown(() => {\r\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\r\n\t\t});\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {Array<string>} events\r\n * @returns {void}\r\n */\r\nexport function delegate(events) {\r\n\tfor (var i = 0; i < events.length; i++) {\r\n\t\tall_registered_events.add(events[i]);\r\n\t}\r\n\r\n\tfor (var fn of root_event_handles) {\r\n\t\tfn(events);\r\n\t}\r\n}\r\n\r\n/**\r\n * @this {EventTarget}\r\n * @param {Event} event\r\n * @returns {void}\r\n */\r\nexport function handle_event_propagation(event) {\r\n\tvar handler_element = this;\r\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\r\n\tvar event_name = event.type;\r\n\tvar path = event.composedPath?.() || [];\r\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\r\n\r\n\t// composedPath contains list of nodes the event has propagated through.\r\n\t// We check __root to skip all nodes below it in case this is a\r\n\t// parent of the __root node, which indicates that there's nested\r\n\t// mounted apps. In this case we don't want to trigger events multiple times.\r\n\tvar path_idx = 0;\r\n\r\n\t// @ts-expect-error is added below\r\n\tvar handled_at = event.__root;\r\n\r\n\tif (handled_at) {\r\n\t\tvar at_idx = path.indexOf(handled_at);\r\n\t\tif (\r\n\t\t\tat_idx !== -1 &&\r\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\r\n\t\t) {\r\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\r\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\r\n\t\t\t// chain in case someone manually dispatches the same event object again.\r\n\t\t\t// @ts-expect-error\r\n\t\t\tevent.__root = handler_element;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// We're deliberately not skipping if the index is higher, because\r\n\t\t// someone could create an event programmatically and emit it multiple times,\r\n\t\t// in which case we want to handle the whole propagation chain properly each time.\r\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\r\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\r\n\t\tvar handler_idx = path.indexOf(handler_element);\r\n\t\tif (handler_idx === -1) {\r\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\r\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (at_idx <= handler_idx) {\r\n\t\t\tpath_idx = at_idx;\r\n\t\t}\r\n\t}\r\n\r\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\r\n\t// there can only be one delegated event per element, and we either already handled the current target,\r\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\r\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\r\n\tif (current_target === handler_element) return;\r\n\r\n\t// Proxy currentTarget to correct target\r\n\tdefine_property(event, 'currentTarget', {\r\n\t\tconfigurable: true,\r\n\t\tget() {\r\n\t\t\treturn current_target || owner_document;\r\n\t\t}\r\n\t});\r\n\r\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\r\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\r\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\r\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\r\n\t// an event handler to run in the context of another reaction or effect.\r\n\tvar previous_reaction = active_reaction;\r\n\tvar previous_effect = active_effect;\r\n\tset_active_reaction(null);\r\n\tset_active_effect(null);\r\n\r\n\ttry {\r\n\t\t/**\r\n\t\t * @type {unknown}\r\n\t\t */\r\n\t\tvar throw_error;\r\n\t\t/**\r\n\t\t * @type {unknown[]}\r\n\t\t */\r\n\t\tvar other_errors = [];\r\n\r\n\t\twhile (current_target !== null) {\r\n\t\t\t/** @type {null | Element} */\r\n\t\t\tvar parent_element =\r\n\t\t\t\tcurrent_target.assignedSlot ||\r\n\t\t\t\tcurrent_target.parentNode ||\r\n\t\t\t\t/** @type {any} */ (current_target).host ||\r\n\t\t\t\tnull;\r\n\r\n\t\t\ttry {\r\n\t\t\t\t// @ts-expect-error\r\n\t\t\t\tvar delegated = current_target['__' + event_name];\r\n\r\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\r\n\t\t\t\t\tif (is_array(delegated)) {\r\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\r\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdelegated.call(current_target, event);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tif (throw_error) {\r\n\t\t\t\t\tother_errors.push(error);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow_error = error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcurrent_target = parent_element;\r\n\t\t}\r\n\r\n\t\tif (throw_error) {\r\n\t\t\tfor (let error of other_errors) {\r\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\r\n\t\t\t\tqueueMicrotask(() => {\r\n\t\t\t\t\tthrow error;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tthrow throw_error;\r\n\t\t}\r\n\t} finally {\r\n\t\t// @ts-expect-error is used above\r\n\t\tevent.__root = handler_element;\r\n\t\t// @ts-ignore remove proxy on currentTarget\r\n\t\tdelete event.currentTarget;\r\n\t\tset_active_reaction(previous_reaction);\r\n\t\tset_active_effect(previous_effect);\r\n\t}\r\n}\r\n\r\n/**\r\n * In dev, warn if an event handler is not a function, as it means the\r\n * user probably called the handler or forgot to add a `() =>`\r\n * @param {() => (event: Event, ...args: any) => void} thunk\r\n * @param {EventTarget} element\r\n * @param {[Event, ...any]} args\r\n * @param {any} component\r\n * @param {[number, number]} [loc]\r\n * @param {boolean} [remove_parens]\r\n */\r\nexport function apply(\r\n\tthunk,\r\n\telement,\r\n\targs,\r\n\tcomponent,\r\n\tloc,\r\n\thas_side_effects = false,\r\n\tremove_parens = false\r\n) {\r\n\tlet handler;\r\n\tlet error;\r\n\r\n\ttry {\r\n\t\thandler = thunk();\r\n\t} catch (e) {\r\n\t\terror = e;\r\n\t}\r\n\r\n\tif (typeof handler === 'function') {\r\n\t\thandler.apply(element, args);\r\n\t} else if (has_side_effects || handler != null) {\r\n\t\tconst filename = component?.[FILENAME];\r\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\r\n\r\n\t\tconst event_name = args[0].type;\r\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\r\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\r\n\r\n\t\tw.event_handler_invalid(description, suggestion);\r\n\r\n\t\tif (error) {\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t}\r\n}\r\n", "/** @import { TemplateNode } from '#client' */\r\nimport { hydrate_node, hydrating, set_hydrate_node, set_hydrating } from '../hydration.js';\r\nimport { create_text, get_first_child, get_next_sibling } from '../operations.js';\r\nimport { block } from '../../reactivity/effects.js';\r\nimport { HEAD_EFFECT } from '../../constants.js';\r\nimport { HYDRATION_START } from '../../../../constants.js';\r\n\r\n/**\r\n * @type {Node | undefined}\r\n */\r\nlet head_anchor;\r\n\r\nexport function reset_head_anchor() {\r\n\thead_anchor = undefined;\r\n}\r\n\r\n/**\r\n * @param {(anchor: Node) => void} render_fn\r\n * @returns {void}\r\n */\r\nexport function head(render_fn) {\r\n\t// The head function may be called after the first hydration pass and ssr comment nodes may still be present,\r\n\t// therefore we need to skip that when we detect that we're not in hydration mode.\r\n\tlet previous_hydrate_node = null;\r\n\tlet was_hydrating = hydrating;\r\n\r\n\t/** @type {Comment | Text} */\r\n\tvar anchor;\r\n\r\n\tif (hydrating) {\r\n\t\tprevious_hydrate_node = hydrate_node;\r\n\r\n\t\t// There might be multiple head blocks in our app, so we need to account for each one needing independent hydration.\r\n\t\tif (head_anchor === undefined) {\r\n\t\t\thead_anchor = /** @type {TemplateNode} */ (get_first_child(document.head));\r\n\t\t}\r\n\r\n\t\twhile (\r\n\t\t\thead_anchor !== null &&\r\n\t\t\t(head_anchor.nodeType !== 8 || /** @type {Comment} */ (head_anchor).data !== HYDRATION_START)\r\n\t\t) {\r\n\t\t\thead_anchor = /** @type {TemplateNode} */ (get_next_sibling(head_anchor));\r\n\t\t}\r\n\r\n\t\t// If we can't find an opening hydration marker, skip hydration (this can happen\r\n\t\t// if a framework rendered body but not head content)\r\n\t\tif (head_anchor === null) {\r\n\t\t\tset_hydrating(false);\r\n\t\t} else {\r\n\t\t\thead_anchor = set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(head_anchor)));\r\n\t\t}\r\n\t}\r\n\r\n\tif (!hydrating) {\r\n\t\tanchor = document.head.appendChild(create_text());\r\n\t}\r\n\r\n\ttry {\r\n\t\tblock(() => render_fn(anchor), HEAD_EFFECT);\r\n\t} finally {\r\n\t\tif (was_hydrating) {\r\n\t\t\tset_hydrating(true);\r\n\t\t\thead_anchor = hydrate_node; // so that next head block starts from the correct node\r\n\t\t\tset_hydrate_node(/** @type {TemplateNode} */ (previous_hydrate_node));\r\n\t\t}\r\n\t}\r\n}\r\n", "/** @param {string} html */\r\nexport function create_fragment_from_html(html) {\r\n\tvar elem = document.createElement('template');\r\n\telem.innerHTML = html;\r\n\treturn elem.content;\r\n}\r\n", "/** @import { Effect, TemplateNode } from '#client' */\r\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\r\nimport { create_text, get_first_child } from './operations.js';\r\nimport { create_fragment_from_html } from './reconciler.js';\r\nimport { active_effect } from '../runtime.js';\r\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\r\nimport { queue_micro_task } from './task.js';\r\n\r\n/**\r\n * @param {TemplateNode} start\r\n * @param {TemplateNode | null} end\r\n */\r\nexport function assign_nodes(start, end) {\r\n\tvar effect = /** @type {Effect} */ (active_effect);\r\n\tif (effect.nodes_start === null) {\r\n\t\teffect.nodes_start = start;\r\n\t\teffect.nodes_end = end;\r\n\t}\r\n}\r\n\r\n/**\r\n * @param {string} content\r\n * @param {number} flags\r\n * @returns {() => Node | Node[]}\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function template(content, flags) {\r\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\r\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\r\n\r\n\t/** @type {Node} */\r\n\tvar node;\r\n\r\n\t/**\r\n\t * Whether or not the first item is a text/element node. If not, we need to\r\n\t * create an additional comment node to act as `effect.nodes.start`\r\n\t */\r\n\tvar has_start = !content.startsWith('<!>');\r\n\r\n\treturn () => {\r\n\t\tif (hydrating) {\r\n\t\t\tassign_nodes(hydrate_node, null);\r\n\t\t\treturn hydrate_node;\r\n\t\t}\r\n\r\n\t\tif (node === undefined) {\r\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\r\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\r\n\t\t}\r\n\r\n\t\tvar clone = /** @type {TemplateNode} */ (\r\n\t\t\tuse_import_node ? document.importNode(node, true) : node.cloneNode(true)\r\n\t\t);\r\n\r\n\t\tif (is_fragment) {\r\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\r\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\r\n\r\n\t\t\tassign_nodes(start, end);\r\n\t\t} else {\r\n\t\t\tassign_nodes(clone, clone);\r\n\t\t}\r\n\r\n\t\treturn clone;\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {string} content\r\n * @param {number} flags\r\n * @returns {() => Node | Node[]}\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function template_with_script(content, flags) {\r\n\tvar fn = template(content, flags);\r\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\r\n}\r\n\r\n/**\r\n * @param {string} content\r\n * @param {number} flags\r\n * @param {'svg' | 'math'} ns\r\n * @returns {() => Node | Node[]}\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function ns_template(content, flags, ns = 'svg') {\r\n\t/**\r\n\t * Whether or not the first item is a text/element node. If not, we need to\r\n\t * create an additional comment node to act as `effect.nodes.start`\r\n\t */\r\n\tvar has_start = !content.startsWith('<!>');\r\n\r\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\r\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\r\n\r\n\t/** @type {Element | DocumentFragment} */\r\n\tvar node;\r\n\r\n\treturn () => {\r\n\t\tif (hydrating) {\r\n\t\t\tassign_nodes(hydrate_node, null);\r\n\t\t\treturn hydrate_node;\r\n\t\t}\r\n\r\n\t\tif (!node) {\r\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\r\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\r\n\r\n\t\t\tif (is_fragment) {\r\n\t\t\t\tnode = document.createDocumentFragment();\r\n\t\t\t\twhile (get_first_child(root)) {\r\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\r\n\r\n\t\tif (is_fragment) {\r\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\r\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\r\n\r\n\t\t\tassign_nodes(start, end);\r\n\t\t} else {\r\n\t\t\tassign_nodes(clone, clone);\r\n\t\t}\r\n\r\n\t\treturn clone;\r\n\t};\r\n}\r\n\r\n/**\r\n * @param {string} content\r\n * @param {number} flags\r\n * @returns {() => Node | Node[]}\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function svg_template_with_script(content, flags) {\r\n\tvar fn = ns_template(content, flags);\r\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\r\n}\r\n\r\n/**\r\n * @param {string} content\r\n * @param {number} flags\r\n * @returns {() => Node | Node[]}\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function mathml_template(content, flags) {\r\n\treturn ns_template(content, flags, 'math');\r\n}\r\n\r\n/**\r\n * Creating a document fragment from HTML that contains script tags will not execute\r\n * the scripts. We need to replace the script tags with new ones so that they are executed.\r\n * @param {Element | DocumentFragment} node\r\n * @returns {Node | Node[]}\r\n */\r\nfunction run_scripts(node) {\r\n\t// scripts were SSR'd, in which case they will run\r\n\tif (hydrating) return node;\r\n\r\n\tconst is_fragment = node.nodeType === 11;\r\n\tconst scripts =\r\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\r\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\r\n\t\t\t: node.querySelectorAll('script');\r\n\tconst effect = /** @type {Effect} */ (active_effect);\r\n\r\n\tfor (const script of scripts) {\r\n\t\tconst clone = document.createElement('script');\r\n\t\tfor (var attribute of script.attributes) {\r\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\r\n\t\t}\r\n\r\n\t\tclone.textContent = script.textContent;\r\n\r\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\r\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\r\n\t\t\teffect.nodes_start = clone;\r\n\t\t}\r\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\r\n\t\t\teffect.nodes_end = clone;\r\n\t\t}\r\n\r\n\t\tscript.replaceWith(clone);\r\n\t}\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\r\n * @param {any} value\r\n */\r\nexport function text(value = '') {\r\n\tif (!hydrating) {\r\n\t\tvar t = create_text(value + '');\r\n\t\tassign_nodes(t, t);\r\n\t\treturn t;\r\n\t}\r\n\r\n\tvar node = hydrate_node;\r\n\r\n\tif (node.nodeType !== 3) {\r\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\r\n\t\tnode.before((node = create_text()));\r\n\t\tset_hydrate_node(node);\r\n\t}\r\n\r\n\tassign_nodes(node, node);\r\n\treturn node;\r\n}\r\n\r\nexport function comment() {\r\n\t// we're not delegating to `template` here for performance reasons\r\n\tif (hydrating) {\r\n\t\tassign_nodes(hydrate_node, null);\r\n\t\treturn hydrate_node;\r\n\t}\r\n\r\n\tvar frag = document.createDocumentFragment();\r\n\tvar start = document.createComment('');\r\n\tvar anchor = create_text();\r\n\tfrag.append(start, anchor);\r\n\r\n\tassign_nodes(start, anchor);\r\n\r\n\treturn frag;\r\n}\r\n\r\n/**\r\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\r\n * and insert the elements into the dom (in client mode).\r\n * @param {Text | Comment | Element} anchor\r\n * @param {DocumentFragment | Element} dom\r\n */\r\nexport function append(anchor, dom) {\r\n\tif (hydrating) {\r\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\r\n\t\thydrate_next();\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (anchor === null) {\r\n\t\t// edge case — void `<svelte:element>` with content\r\n\t\treturn;\r\n\t}\r\n\r\n\tanchor.before(/** @type {Node} */ (dom));\r\n}\r\n", "/** @import { ComponentContext, Effect, TemplateNode } from '#client' */\r\n/** @import { Component, ComponentType, SvelteComponent } from '../../index.js' */\r\nimport { DEV } from 'esm-env';\r\nimport {\r\n\tclear_text_content,\r\n\tcreate_text,\r\n\tget_first_child,\r\n\tget_next_sibling,\r\n\tinit_operations\r\n} from './dom/operations.js';\r\nimport { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js';\r\nimport { push, pop, component_context, active_effect } from './runtime.js';\r\nimport { effect_root, branch } from './reactivity/effects.js';\r\nimport {\r\n\thydrate_next,\r\n\thydrate_node,\r\n\thydrating,\r\n\tset_hydrate_node,\r\n\tset_hydrating\r\n} from './dom/hydration.js';\r\nimport { array_from } from '../shared/utils.js';\r\nimport {\r\n\tall_registered_events,\r\n\thandle_event_propagation,\r\n\troot_event_handles\r\n} from './dom/elements/events.js';\r\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\r\nimport * as w from './warnings.js';\r\nimport * as e from './errors.js';\r\nimport { assign_nodes } from './dom/template.js';\r\nimport { is_passive_event } from '../../utils.js';\r\n\r\n/**\r\n * This is normally true — block effects should run their intro transitions —\r\n * but is false during hydration (unless `options.intro` is `true`) and\r\n * when creating the children of a `<svelte:element>` that just changed tag\r\n */\r\nexport let should_intro = true;\r\n\r\n/** @param {boolean} value */\r\nexport function set_should_intro(value) {\r\n\tshould_intro = value;\r\n}\r\n\r\n/**\r\n * @param {Element} text\r\n * @param {string} value\r\n * @returns {void}\r\n */\r\nexport function set_text(text, value) {\r\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\r\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\r\n\t// @ts-expect-error\r\n\tif (str !== (text.__t ??= text.nodeValue)) {\r\n\t\t// @ts-expect-error\r\n\t\ttext.__t = str;\r\n\t\ttext.nodeValue = str == null ? '' : str + '';\r\n\t}\r\n}\r\n\r\n/**\r\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.\r\n * Transitions will play during the initial render unless the `intro` option is set to `false`.\r\n *\r\n * @template {Record<string, any>} Props\r\n * @template {Record<string, any>} Exports\r\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\r\n * @param {{} extends Props ? {\r\n * \t\ttarget: Document | Element | ShadowRoot;\r\n * \t\tanchor?: Node;\r\n * \t\tprops?: Props;\r\n * \t\tevents?: Record<string, (e: any) => any>;\r\n * \t\tcontext?: Map<any, any>;\r\n * \t\tintro?: boolean;\r\n * \t}: {\r\n * \t\ttarget: Document | Element | ShadowRoot;\r\n * \t\tprops: Props;\r\n * \t\tanchor?: Node;\r\n * \t\tevents?: Record<string, (e: any) => any>;\r\n * \t\tcontext?: Map<any, any>;\r\n * \t\tintro?: boolean;\r\n * \t}} options\r\n * @returns {Exports}\r\n */\r\nexport function mount(component, options) {\r\n\treturn _mount(component, options);\r\n}\r\n\r\n/**\r\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\r\n *\r\n * @template {Record<string, any>} Props\r\n * @template {Record<string, any>} Exports\r\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\r\n * @param {{} extends Props ? {\r\n * \t\ttarget: Document | Element | ShadowRoot;\r\n * \t\tprops?: Props;\r\n * \t\tevents?: Record<string, (e: any) => any>;\r\n *  \tcontext?: Map<any, any>;\r\n * \t\tintro?: boolean;\r\n * \t\trecover?: boolean;\r\n * \t} : {\r\n * \t\ttarget: Document | Element | ShadowRoot;\r\n * \t\tprops: Props;\r\n * \t\tevents?: Record<string, (e: any) => any>;\r\n *  \tcontext?: Map<any, any>;\r\n * \t\tintro?: boolean;\r\n * \t\trecover?: boolean;\r\n * \t}} options\r\n * @returns {Exports}\r\n */\r\nexport function hydrate(component, options) {\r\n\tinit_operations();\r\n\toptions.intro = options.intro ?? false;\r\n\tconst target = options.target;\r\n\tconst was_hydrating = hydrating;\r\n\tconst previous_hydrate_node = hydrate_node;\r\n\r\n\ttry {\r\n\t\tvar anchor = /** @type {TemplateNode} */ (get_first_child(target));\r\n\t\twhile (\r\n\t\t\tanchor &&\r\n\t\t\t(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)\r\n\t\t) {\r\n\t\t\tanchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));\r\n\t\t}\r\n\r\n\t\tif (!anchor) {\r\n\t\t\tthrow HYDRATION_ERROR;\r\n\t\t}\r\n\r\n\t\tset_hydrating(true);\r\n\t\tset_hydrate_node(/** @type {Comment} */ (anchor));\r\n\t\thydrate_next();\r\n\r\n\t\tconst instance = _mount(component, { ...options, anchor });\r\n\r\n\t\tif (\r\n\t\t\thydrate_node === null ||\r\n\t\t\thydrate_node.nodeType !== 8 ||\r\n\t\t\t/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END\r\n\t\t) {\r\n\t\t\tw.hydration_mismatch();\r\n\t\t\tthrow HYDRATION_ERROR;\r\n\t\t}\r\n\r\n\t\tset_hydrating(false);\r\n\r\n\t\treturn /**  @type {Exports} */ (instance);\r\n\t} catch (error) {\r\n\t\tif (error === HYDRATION_ERROR) {\r\n\t\t\tif (options.recover === false) {\r\n\t\t\t\te.hydration_failed();\r\n\t\t\t}\r\n\r\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\r\n\t\t\tinit_operations();\r\n\t\t\tclear_text_content(target);\r\n\r\n\t\t\tset_hydrating(false);\r\n\t\t\treturn mount(component, options);\r\n\t\t}\r\n\r\n\t\tthrow error;\r\n\t} finally {\r\n\t\tset_hydrating(was_hydrating);\r\n\t\tset_hydrate_node(previous_hydrate_node);\r\n\t\treset_head_anchor();\r\n\t}\r\n}\r\n\r\n/** @type {Map<string, number>} */\r\nconst document_listeners = new Map();\r\n\r\n/**\r\n * @template {Record<string, any>} Exports\r\n * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component\r\n * @param {{\r\n * \t\ttarget: Document | Element | ShadowRoot;\r\n * \t\tanchor?: Node;\r\n * \t\tprops?: any;\r\n * \t\tevents?: any;\r\n * \t\tcontext?: Map<any, any>;\r\n * \t\tintro?: boolean;\r\n * \t}} options\r\n * @returns {Exports}\r\n */\r\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\r\n\tinit_operations();\r\n\r\n\tvar registered_events = new Set();\r\n\r\n\t/** @param {Array<string>} events */\r\n\tvar event_handle = (events) => {\r\n\t\tfor (var i = 0; i < events.length; i++) {\r\n\t\t\tvar event_name = events[i];\r\n\r\n\t\t\tif (registered_events.has(event_name)) continue;\r\n\t\t\tregistered_events.add(event_name);\r\n\r\n\t\t\tvar passive = is_passive_event(event_name);\r\n\r\n\t\t\t// Add the event listener to both the container and the document.\r\n\t\t\t// The container listener ensures we catch events from within in case\r\n\t\t\t// the outer content stops propagation of the event.\r\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\r\n\r\n\t\t\tvar n = document_listeners.get(event_name);\r\n\r\n\t\t\tif (n === undefined) {\r\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\r\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\r\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\r\n\t\t\t\tdocument_listeners.set(event_name, 1);\r\n\t\t\t} else {\r\n\t\t\t\tdocument_listeners.set(event_name, n + 1);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tevent_handle(array_from(all_registered_events));\r\n\troot_event_handles.add(event_handle);\r\n\r\n\t/** @type {Exports} */\r\n\t// @ts-expect-error will be defined because the render effect runs synchronously\r\n\tvar component = undefined;\r\n\r\n\tvar unmount = effect_root(() => {\r\n\t\tvar anchor_node = anchor ?? target.appendChild(create_text());\r\n\r\n\t\tbranch(() => {\r\n\t\t\tif (context) {\r\n\t\t\t\tpush({});\r\n\t\t\t\tvar ctx = /** @type {ComponentContext} */ (component_context);\r\n\t\t\t\tctx.c = context;\r\n\t\t\t}\r\n\r\n\t\t\tif (events) {\r\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\r\n\t\t\t\t/** @type {any} */ (props).$$events = events;\r\n\t\t\t}\r\n\r\n\t\t\tif (hydrating) {\r\n\t\t\t\tassign_nodes(/** @type {TemplateNode} */ (anchor_node), null);\r\n\t\t\t}\r\n\r\n\t\t\tshould_intro = intro;\r\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\r\n\t\t\tcomponent = Component(anchor_node, props) || {};\r\n\t\t\tshould_intro = true;\r\n\r\n\t\t\tif (hydrating) {\r\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\r\n\t\t\t}\r\n\r\n\t\t\tif (context) {\r\n\t\t\t\tpop();\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn () => {\r\n\t\t\tfor (var event_name of registered_events) {\r\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\r\n\r\n\t\t\t\tvar n = /** @type {number} */ (document_listeners.get(event_name));\r\n\r\n\t\t\t\tif (--n === 0) {\r\n\t\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\r\n\t\t\t\t\tdocument_listeners.delete(event_name);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdocument_listeners.set(event_name, n);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\troot_event_handles.delete(event_handle);\r\n\t\t\tmounted_components.delete(component);\r\n\t\t\tif (anchor_node !== anchor) {\r\n\t\t\t\tanchor_node.parentNode?.removeChild(anchor_node);\r\n\t\t\t}\r\n\t\t};\r\n\t});\r\n\r\n\tmounted_components.set(component, unmount);\r\n\treturn component;\r\n}\r\n\r\n/**\r\n * References of the components that were mounted or hydrated.\r\n * Uses a `WeakMap` to avoid memory leaks.\r\n */\r\nlet mounted_components = new WeakMap();\r\n\r\n/**\r\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\r\n * @param {Record<string, any>} component\r\n */\r\nexport function unmount(component) {\r\n\tconst fn = mounted_components.get(component);\r\n\r\n\tif (fn) {\r\n\t\tfn();\r\n\t} else if (DEV) {\r\n\t\tw.lifecycle_double_unmount();\r\n\t}\r\n}\r\n", "/** @import { ActionReturn } from 'svelte/action' */\r\nimport { noop } from '../../../shared/utils.js';\r\nimport { user_pre_effect } from '../../reactivity/effects.js';\r\nimport { on } from '../elements/events.js';\r\n\r\n/**\r\n * Substitute for the `trusted` event modifier\r\n * @deprecated\r\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\r\n * @returns {(event: Event, ...args: unknown[]) => void}\r\n */\r\nexport function trusted(fn) {\r\n\treturn function (...args) {\r\n\t\tvar event = /** @type {Event} */ (args[0]);\r\n\t\tif (event.isTrusted) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tfn?.apply(this, args);\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * Substitute for the `self` event modifier\r\n * @deprecated\r\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\r\n * @returns {(event: Event, ...args: unknown[]) => void}\r\n */\r\nexport function self(fn) {\r\n\treturn function (...args) {\r\n\t\tvar event = /** @type {Event} */ (args[0]);\r\n\t\t// @ts-ignore\r\n\t\tif (event.target === this) {\r\n\t\t\t// @ts-ignore\r\n\t\t\tfn?.apply(this, args);\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * Substitute for the `stopPropagation` event modifier\r\n * @deprecated\r\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\r\n * @returns {(event: Event, ...args: unknown[]) => void}\r\n */\r\nexport function stopPropagation(fn) {\r\n\treturn function (...args) {\r\n\t\tvar event = /** @type {Event} */ (args[0]);\r\n\t\tevent.stopPropagation();\r\n\t\t// @ts-ignore\r\n\t\treturn fn?.apply(this, args);\r\n\t};\r\n}\r\n\r\n/**\r\n * Substitute for the `once` event modifier\r\n * @deprecated\r\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\r\n * @returns {(event: Event, ...args: unknown[]) => void}\r\n */\r\nexport function once(fn) {\r\n\tvar ran = false;\r\n\r\n\treturn function (...args) {\r\n\t\tif (ran) return;\r\n\t\tran = true;\r\n\r\n\t\t// @ts-ignore\r\n\t\treturn fn?.apply(this, args);\r\n\t};\r\n}\r\n\r\n/**\r\n * Substitute for the `stopImmediatePropagation` event modifier\r\n * @deprecated\r\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\r\n * @returns {(event: Event, ...args: unknown[]) => void}\r\n */\r\nexport function stopImmediatePropagation(fn) {\r\n\treturn function (...args) {\r\n\t\tvar event = /** @type {Event} */ (args[0]);\r\n\t\tevent.stopImmediatePropagation();\r\n\t\t// @ts-ignore\r\n\t\treturn fn?.apply(this, args);\r\n\t};\r\n}\r\n\r\n/**\r\n * Substitute for the `preventDefault` event modifier\r\n * @deprecated\r\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\r\n * @returns {(event: Event, ...args: unknown[]) => void}\r\n */\r\nexport function preventDefault(fn) {\r\n\treturn function (...args) {\r\n\t\tvar event = /** @type {Event} */ (args[0]);\r\n\t\tevent.preventDefault();\r\n\t\t// @ts-ignore\r\n\t\treturn fn?.apply(this, args);\r\n\t};\r\n}\r\n\r\n/**\r\n * Substitute for the `passive` event modifier, implemented as an action\r\n * @deprecated\r\n * @param {HTMLElement} node\r\n * @param {[event: string, handler: () => EventListener]} options\r\n */\r\nexport function passive(node, [event, handler]) {\r\n\tuser_pre_effect(() => {\r\n\t\treturn on(node, event, handler() ?? noop, {\r\n\t\t\tpassive: true\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Substitute for the `nonpassive` event modifier, implemented as an action\r\n * @deprecated\r\n * @param {HTMLElement} node\r\n * @param {[event: string, handler: () => EventListener]} options\r\n */\r\nexport function nonpassive(node, [event, handler]) {\r\n\tuser_pre_effect(() => {\r\n\t\treturn on(node, event, handler() ?? noop, {\r\n\t\t\tpassive: false\r\n\t\t});\r\n\t});\r\n}\r\n", "/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */\r\nimport { DIRTY, MAYBE_DIRTY } from '../internal/client/constants.js';\r\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\r\nimport { mutable_source, set } from '../internal/client/reactivity/sources.js';\r\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\r\nimport {\r\n\tactive_effect,\r\n\tcomponent_context,\r\n\tflush_sync,\r\n\tget,\r\n\tset_signal_status\r\n} from '../internal/client/runtime.js';\r\nimport { lifecycle_outside_component } from '../internal/shared/errors.js';\r\nimport { define_property, is_array } from '../internal/shared/utils.js';\r\nimport * as w from '../internal/client/warnings.js';\r\n\r\n/**\r\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\r\n *\r\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\r\n *\r\n * @template {Record<string, any>} Props\r\n * @template {Record<string, any>} Exports\r\n * @template {Record<string, any>} Events\r\n * @template {Record<string, any>} Slots\r\n *\r\n * @param {ComponentConstructorOptions<Props> & {\r\n * \tcomponent: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;\r\n * }} options\r\n * @returns {SvelteComponent<Props, Events, Slots> & Exports}\r\n */\r\nexport function createClassComponent(options) {\r\n\t// @ts-expect-error $$prop_def etc are not actually defined\r\n\treturn new Svelte4Component(options);\r\n}\r\n\r\n/**\r\n * Takes the component function and returns a Svelte 4 compatible component constructor.\r\n *\r\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\r\n *\r\n * @template {Record<string, any>} Props\r\n * @template {Record<string, any>} Exports\r\n * @template {Record<string, any>} Events\r\n * @template {Record<string, any>} Slots\r\n *\r\n * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component\r\n * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}\r\n */\r\nexport function asClassComponent(component) {\r\n\t// @ts-expect-error $$prop_def etc are not actually defined\r\n\treturn class extends Svelte4Component {\r\n\t\t/** @param {any} options */\r\n\t\tconstructor(options) {\r\n\t\t\tsuper({\r\n\t\t\t\tcomponent,\r\n\t\t\t\t...options\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n\r\nclass Svelte4Component {\r\n\t/** @type {any} */\r\n\t#events;\r\n\r\n\t/** @type {Record<string, any>} */\r\n\t#instance;\r\n\r\n\t/**\r\n\t * @param {ComponentConstructorOptions & {\r\n\t *  component: any;\r\n\t * }} options\r\n\t */\r\n\tconstructor(options) {\r\n\t\tvar sources = new Map();\r\n\r\n\t\t/**\r\n\t\t * @param {string | symbol} key\r\n\t\t * @param {unknown} value\r\n\t\t */\r\n\t\tvar add_source = (key, value) => {\r\n\t\t\tvar s = mutable_source(value);\r\n\t\t\tsources.set(key, s);\r\n\t\t\treturn s;\r\n\t\t};\r\n\r\n\t\t// Replicate coarse-grained props through a proxy that has a version source for\r\n\t\t// each property, which is increment on updates to the property itself. Do not\r\n\t\t// use our $state proxy because that one has fine-grained reactivity.\r\n\t\tconst props = new Proxy(\r\n\t\t\t{ ...(options.props || {}), $$events: {} },\r\n\t\t\t{\r\n\t\t\t\tget(target, prop) {\r\n\t\t\t\t\treturn get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\r\n\t\t\t\t},\r\n\t\t\t\thas(target, prop) {\r\n\t\t\t\t\tget(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\r\n\t\t\t\t\treturn Reflect.has(target, prop);\r\n\t\t\t\t},\r\n\t\t\t\tset(target, prop, value) {\r\n\t\t\t\t\tset(sources.get(prop) ?? add_source(prop, value), value);\r\n\t\t\t\t\treturn Reflect.set(target, prop, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\r\n\t\t\ttarget: options.target,\r\n\t\t\tprops,\r\n\t\t\tcontext: options.context,\r\n\t\t\tintro: options.intro ?? false,\r\n\t\t\trecover: options.recover\r\n\t\t});\r\n\r\n\t\t// We don't flush_sync for custom element wrappers or if the user doesn't want it\r\n\t\tif (!options?.props?.$$host || options.sync === false) {\r\n\t\t\tflush_sync();\r\n\t\t}\r\n\r\n\t\tthis.#events = props.$$events;\r\n\r\n\t\tfor (const key of Object.keys(this.#instance)) {\r\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\r\n\t\t\tdefine_property(this, key, {\r\n\t\t\t\tget() {\r\n\t\t\t\t\treturn this.#instance[key];\r\n\t\t\t\t},\r\n\t\t\t\t/** @param {any} value */\r\n\t\t\t\tset(value) {\r\n\t\t\t\t\tthis.#instance[key] = value;\r\n\t\t\t\t},\r\n\t\t\t\tenumerable: true\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\r\n\t\t\tObject.assign(props, next);\r\n\t\t};\r\n\r\n\t\tthis.#instance.$destroy = () => {\r\n\t\t\tunmount(this.#instance);\r\n\t\t};\r\n\t}\r\n\r\n\t/** @param {Record<string, any>} props */\r\n\t$set(props) {\r\n\t\tthis.#instance.$set(props);\r\n\t}\r\n\r\n\t/**\r\n\t * @param {string} event\r\n\t * @param {(...args: any[]) => any} callback\r\n\t * @returns {any}\r\n\t */\r\n\t$on(event, callback) {\r\n\t\tthis.#events[event] = this.#events[event] || [];\r\n\r\n\t\t/** @param {any[]} args */\r\n\t\tconst cb = (...args) => callback.call(this, ...args);\r\n\t\tthis.#events[event].push(cb);\r\n\t\treturn () => {\r\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\r\n\t\t};\r\n\t}\r\n\r\n\t$destroy() {\r\n\t\tthis.#instance.$destroy();\r\n\t}\r\n}\r\n\r\n/**\r\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\r\n *\r\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\r\n * @param {() => void | (() => void)} fn\r\n * @returns {void}\r\n */\r\nexport function run(fn) {\r\n\tuser_pre_effect(() => {\r\n\t\tfn();\r\n\t\tvar effect = /** @type {import('#client').Effect} */ (active_effect);\r\n\t\t// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour\r\n\t\tif ((effect.f & DIRTY) !== 0) {\r\n\t\t\tw.legacy_recursive_reactive_block();\r\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n/**\r\n * Function to mimic the multiple listeners available in svelte 4\r\n * @deprecated\r\n * @param {EventListener[]} handlers\r\n * @returns {EventListener}\r\n */\r\nexport function handlers(...handlers) {\r\n\treturn function (event) {\r\n\t\tconst { stopImmediatePropagation } = event;\r\n\t\tlet stopped = false;\r\n\r\n\t\tevent.stopImmediatePropagation = () => {\r\n\t\t\tstopped = true;\r\n\t\t\tstopImmediatePropagation.call(event);\r\n\t\t};\r\n\r\n\t\tconst errors = [];\r\n\r\n\t\tfor (const handler of handlers) {\r\n\t\t\ttry {\r\n\t\t\t\t// @ts-expect-error `this` is not typed\r\n\t\t\t\thandler?.call(this, event);\r\n\t\t\t} catch (e) {\r\n\t\t\t\terrors.push(e);\r\n\t\t\t}\r\n\r\n\t\t\tif (stopped) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (let error of errors) {\r\n\t\t\tqueueMicrotask(() => {\r\n\t\t\t\tthrow error;\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n\r\n/**\r\n * Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.\r\n * @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.\r\n */\r\nexport function createBubbler() {\r\n\tconst active_component_context = component_context;\r\n\tif (active_component_context === null) {\r\n\t\tlifecycle_outside_component('createBubbler');\r\n\t}\r\n\r\n\treturn (/**@type {string}*/ type) => (/**@type {Event}*/ event) => {\r\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\r\n\t\t\tactive_component_context.s.$$events\r\n\t\t)?.[/** @type {any} */ (type)];\r\n\r\n\t\tif (events) {\r\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\r\n\t\t\tfor (const fn of callbacks) {\r\n\t\t\t\tfn.call(active_component_context.x, event);\r\n\t\t\t}\r\n\t\t\treturn !event.defaultPrevented;\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n}\r\n\r\nexport {\r\n\tonce,\r\n\tpreventDefault,\r\n\tself,\r\n\tstopImmediatePropagation,\r\n\tstopPropagation,\r\n\ttrusted,\r\n\tpassive,\r\n\tnonpassive\r\n} from '../internal/client/dom/legacy/event-modifiers.js';\r\n"],
  "mappings": "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",
  "names": ["events", "passive", "unmount", "handlers", "stopImmediatePropagation"]
}
